{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../App.svelte",
    "../../SuppEvalAlt.svelte"
  ],
  "sourcesContent": [
    "<script>\n    import * as d3 from \"d3\";\n    import * as druid from \"@saehrimnir/druidjs\";\n\n    import Eval from \"./Eval.svelte\";\n    import Scatterplot from \"./Scatterplot.svelte\";\n    import Compare from \"./Compare.svelte\";\n    import SmallComp from \"./SmallComp.svelte\";\n    import SmallCompAlt from \"./SmallCompAlt.svelte\";\n    import SuppComp from \"./SuppComp.svelte\";\n    import SuppEval from \"./SuppEval.svelte\";\n    import SuppEvalAlt from \"./SuppEvalAlt.svelte\";\n    import ScatterPlotAlt from \"./ScatterPlotAlt.svelte\";\n\n    let w = 15;\n    let h = 15;\n    let margin = 50;\n\n    async function load_data(path) {\n        let data = await d3.json(path)\n        //data.PCA = data.PCA.map(rows => rows.filter((d, i) => i < 32));\n        for (const key of Object.keys(data)) {\n            data[key] = data[key].map(rows => rows.filter((d, i) => i >= 1 && i < 32))\n        }\n        data = {\n            \"PCA\": data.PCA || [],//.map(rows => rows.filter((d, i) => i >= 1 && i < 32)),\n            \"LLE\": data.LLE || [],//.map(rows => rows.filter((d, i) => i >= 1 && i < 32)),\n            \"TSNE\": data.TSNE || [],//.map(rows => rows.filter((d, i) => i >= 1 && i < 32)),\n            \"MDS\": data.MDS || [],//.map(rows => rows.filter((d, i) => i >= 1 && i < 32)),\n            \"ISOMAP\": data.ISOMAP || [],//.map(rows => rows.filter((d, i) => i >= 1 && i < 32)),\n            \"UMAP\": data.UMAP || [],//.map(rows => rows.filter((d, i) => i >= 1 && i < 32)),\n        };\n        return data\n    }\n\n    async function load_data2() {\n        try {\n            return [await load_data(\"eval6_8x14.json\"), await load_data(\"eval_sklearn.json\"), await load_data(\"eval_js.json\"), await load_data(\"eval_supp.json\")]\n        } catch(e) {\n            console.warn(e)\n        }\n    }\n\n    async function load_data_supp(path, lib) {\n        let D = await d3.json(path);\n        let data = Object.keys(D).map((key) => {\n            let rows = D[key].map((row, i) => {\n                return row.filter((d, i) => i >= 1 && i < 32 && d != 0)\n            });\n            rows.DR = key;\n            rows.LIB = lib;\n            return rows;\n        })\n        return data//.filter(d => d.LIB != \"druid\");\n    }\n\n    async function load_supp(full=true) {\n        let D = []\n        let list = full ? [[\"eval6_8x14.json\", \"druid\"], [\"eval_sklearn.json\", \"sklearn\"], [\"eval_js.json\", \"js\"], [\"eval_supp.json\", \"druid\"]] : [[\"eval6_8x14.json\", \"druid\"], [\"eval_supp.json\", \"druid\"]]\n        for (const [path, lib] of list) {\n            D.push(await load_data_supp(path, lib))\n        }\n        return D.flat()\n            .sort((a, b) => d3.ascending(a.DR, b.DR))\n            .sort((a, b) => d3.ascending(a.LIB, b.LIB))\n    }\n\n    async function load_small(t) {\n        let [data, dataSK, dataJS] = await load_data2();\n        let Ns = d3.range(Math.max(...[Object.values(data), Object.values(dataSK), Object.values(dataJS)].flat().flat().map(d => d.filter(d => d != 0).length)))\n            .map(n => Math.floor(16 + 2 ** (n/2 + 1)));\n        let Ds = d3.range([Object.values(data)[0].length]).map(d => Math.floor(2 * 5**((d+1)/2)));\n        let D = d3.zip(Object.values(data), Object.values(dataSK), Object.values(dataJS))\n            .map(([dr, sk, js], i) => {\n                if (t == 1) {\n                    dr = d3.range(27)\n                        .map(j => dr[j] || [])\n                        .map(row => row.filter(d => d != 0)\n                        .map(d => d3.extent(d.dur, d => d[2] - d[0]).map(d => [d, \"dr\"])));\n                    sk = d3.range(27).map(j => sk[j] || []).map(row => row.filter(d => d != 0).map(d => d3.extent(d.dur, d => d[2] - d[0]).map(d => [d, \"sk\"])));\n                    js = d3.range(27).map(j => js[j] || []).map(row => row.filter(d => d != 0).map(d => d3.extent(d.dur, d => d[2] - d[0]).map(d => [d, \"js\"])));\n                    return [dr, sk, js]\n                } else {\n                    dr = d3.range(27).map(j => dr[j] || []).map(row => row.filter(d => d != 0).map(d => [d3.mean(d.dur, d => d[2] - d[0]), \"druid\"]));\n                    sk = d3.range(27).map(j => sk[j] || []).map(row => row.filter(d => d != 0).map(d => [d3.mean(d.dur, d => d[2] - d[0]), \"sklearn\"]));\n                    js = d3.range(27).map(j => js[j] || []).map(row => row.filter(d => d != 0).map(d => [d3.mean(d.dur, d => d[2] - d[0]), \"js\"]));\n                    return [dr, sk, js]\n                }\n            })\n            .map(([dr, sk, js], i) => {\n                //console.log(dr, sk, js)\n                return Ds.map((d, j) => {\n                    return Ns.slice(0, 31).map((n, k) => {\n                        return {\n                            d: j,\n                            n: k,\n                            winner: winner(dr[j][k], sk[j][k], js[j][k], t),\n                            m: Object.keys(data)[i],\n                        }\n                    })\n                })\n            })\n            \n        D.keys = Object.keys(data);\n        return D;\n    }\n\n    function winner(dr, sk, js, t) {\n        if (t == 1) {\n            let values = [dr, sk, js].filter(d => d)\n            if (values.length == 0) return \"none\"\n            let [f, s, ...rest] = values.flat()\n                /* .filter(d => ) */\n                .sort((a, b) => d3.ascending(a[0] || null, b[0] || null));\n            \n            switch (f[1] + s[1]) {\n                case \"sksk\": return \"sklearn\";\n                case \"skdr\":\n                case \"drsk\":\n                    return \"dr_sk\";\n                case \"drdr\": return \"druid\";\n                case \"drjs\":\n                case \"jsdr\":\n                    return \"dr_js\";\n                case \"jsjs\": return \"js\";\n                case \"skjs\":\n                case \"jssk\":\n                    return \"sk_js\";\n                default: return \"both\";\n            }\n        } else {\n            let T = [dr, sk, js]\n                .filter(d => d)\n                .sort((a, b) => d3.ascending(a[0], b[0]))\n            if (T.length == 0) return \"none\"\n            if (T[0][1] == \"druid\") {\n                return \"druid\"\n            }\n            if (T.slice(1).findIndex(d => d[1] == \"druid\") >= 0) {\n                let druid_time = T.slice(1).find(d => d[1] == \"druid\")[0]\n                let p = druid_time / T[0][0] ;\n                let suffix = \"\"\n                if (p < 2) {\n                    suffix = \"2\";\n                } else if (p < 5) {\n                    suffix = \"5\";\n                } else if (p < 10) {\n                    suffix = \"10\";\n                } else {\n                    suffix = \"x\";\n                }\n                return T[0][1] + suffix\n            }\n            return T[0][1];\n        }\n        \n    }\n    \n    /* function win(l, r) {\n        if (l == undefined && r != undefined) return \"r\";\n        if (l != undefined && r == undefined) return \"l\";\n        if (l == undefined && r == undefined) return \"none\";\n        if (r[0] <= l[0] && r[1] <= l[0]) return \"r\";\n        if (l[0] <= r[0] && l[1] <= r[0]) return \"l\";\n        return \"draw\"\n    } */\n\n    async function comp_dr(X, DR) {\n        let dims = [\"bill_depth_mm\", \"bill_length_mm\", \"flipper_length_mm\", \"body_mass_g\"]\n        let maxes = dims.map(key => d3.max(X, d => +d[key]))\n        let classes = X.map(d => d.species);\n        let values = X.map(d => dims.map((key, i) => +d[key] / maxes[i]))\n        const V = druid.Matrix.from(values)\n        let Y = comp(V, DR, classes);\n        return Y\n    }\n\n    function comp(V, DR, classes) {\n        return new Promise(res => {\n            switch (DR) {\n                case \"UMAP\":\n                    new druid.UMAP(V).transform_async().then(Y => {\n                        res(Y.to2dArray)\n                    });\n                    break;\n                case \"TSNE\":\n                    new druid.TSNE(V).transform_async().then(Y => res(Y.to2dArray));\n                    break;\n                case \"LDA\":\n                    new druid.LDA(V, V.to2dArray.map(d => 0)).transform_async().then(Y => res(Y.to2dArray));\n                    break;\n                case \"ISOMAP\":\n                    new druid.ISOMAP(V).transform_async().then(Y => res(Y.to2dArray));\n                    break;\n                case \"MDS\":\n                    new druid.MDS(V).transform_async().then(Y => res(Y.to2dArray));\n                    break;\n                case \"PCA\":\n                    new druid.PCA(V).transform_async().then(Y => res(Y.to2dArray));\n                    break;\n                case \"MDS\":\n                    new druid.MDS(V).transform_async().then(Y => res(Y.to2dArray));\n                    break;\n                case \"LLE\":\n                    new druid.LLE(V, 34).transform_async().then(Y => res(Y.to2dArray));\n                    break;\n                case \"LTSA\":\n                    new druid.LTSA(V ,34).transform_async().then(Y => res(Y.to2dArray));\n                    break;\n                case \"TriMap\":\n                    new druid.TriMap(V, 100000, 4).init().transform_async().then(Y => res(Y.to2dArray));\n                    break;\n                default:\n                    new druid.FASTMAP(V).transform_async().then(Y => res(Y.to2dArray));\n                    break;\n            }\n        })\n    }\n\n    let R;\n    let computing = false;\n    let t;\n    let interval;\n    let start = performance.now();\n\n    function wait(t) {\n        return new Promise(res => {\n            window.setTimeout(res, t);\n        })\n    }\n\n\n    async function selected(e) {\n        if (computing) return;\n        try {\n            R = null;\n            const {d, n, dr} = e.detail;\n            let computing = true;\n\n            let X = new druid.Matrix(n, d, () => Math.random());\n            await wait(10)\n            start = performance.now()\n            /* let ifunc = (start) => {\n                \n                console.log(start, t)\n                t = Math.round(performance.now() - start);\n            }\n            interval = window.setInterval(ifunc, 10, start) */\n            comp(X, dr).then(async Y => {\n                t = d3.format(\".2f\")(performance.now() - start);\n\n                await wait(10)\n                R = {Y: Y, DR: dr, d: d, n: n};\n                window.clearInterval(interval);\n                computing = false;\n                \n            });\n\n        } catch(e) {\n            window.clearInterval(interval)\n        } finally {\n        }\n    }\n\n</script>\n\n<main>\n    <aside on:mouseenter={() => {R=null; t=undefined}}>\n        <ScatterPlotAlt Y={R ? R.Y : []} DR={R?.DR} d={R?.d} n={R?.n}></ScatterPlotAlt>\n        {#if t != undefined}<p font-family=\"Courier Prime\"><span>Runtime</span> {t}ms</p>{/if}\n        \n    </aside>\n    <section>\n        {#await load_supp(false)}\n            <p></p>\n        {:then D}\n            <SuppEvalAlt \n                D={D}\n                on:select={selected} computing={computing}>\n            </SuppEvalAlt>\n        {/await}\n       <!--  {#await load_data(\"eval6_8x14.json\")}\n            <p>eval</p>\n        {:then data}\n            <Eval \n                data={data}\n                w={w}\n                h={h}\n                margin={margin}\n            \n            ></Eval>\n        {/await} -->\n        <!-- {#await load_supp()}\n            <p>wait for it...</p>\n        {:then D}\n            <SuppComp D={D}>\n            </SuppComp>\n        {/await} -->\n        <!-- {#await load_supp()}\n            <p>wait for it...</p>\n        {:then D}\n            <SuppEval D={D}>\n            </SuppEval>\n        {/await}-->\n        \n        <!-- {#await load_small(1)}\n            <p>small comp</p>\n        {:then D}\n            <SmallComp\n                data={D}>\n            </SmallComp>\n        {/await} -->\n        <!-- {#await load_small(0)}\n            <p>small comp</p>\n        {:then D}\n            <SmallCompAlt\n                data={D}>\n            </SmallCompAlt>\n        {/await} -->\n        <!-- {#await load_data2()}\n            <p>compare</p>\n        {:then D}\n\n            <Compare data={D[0]} dataSK={D[1]} dataJS={D[2]}></Compare>\n        {/await} -->\n        \n    </section>\n    <section>\n        <!-- {#await d3.csv(\"penguins.csv\")}\n            wait\n        {:then data}\n            {#each [\"FASTMAP\", \"ISOMAP\", \"LDA\", \"LLE\", \"LTSA\", \"MDS\", \"PCA\", \"TSNE\", \"TriMap\", \"UMAP\"] as DR}\n                {#await comp_dr(data, DR)}\n                    <p>compute {DR}</p>\n                {:then Y}\n                    <Scatterplot X={data} DR={DR} Y={Y}></Scatterplot>\n                {/await}\n            {/each}\n        {/await} -->\n    </section>\n</main>\n\n<style>\n\t:global(svg) {\n        background-color: #f0f0f0;\n    }\n\n    aside {\n        position: fixed;\n        top: 1rem;\n        right: 1rem;\n\n    }\n\n    section { \n        margin-bottom: 100vh;\n    }\n</style>",
    "<script>\n    import * as d3 from \"d3\";\n    import { onMount, createEventDispatcher } from \"svelte\";\n    import download from \"downloadjs\";\n\n    export let D;\n    export let computing;\n\tconst dispatch = createEventDispatcher();\n\n    let W = 24;\n    let h = 24;\n    let hm = 3;\n    let H = 8 * (h + hm);\n    let wm = 3;\n    let m = 25;\n    let ch = 5;\n    let margin = {\n        top: 50 + (8 * ch) + wm,\n        top2: 55,\n        left: 80,\n        bottom: 65,\n        right: 30,\n    };\n\n\n    let C = d3.scaleSequential(d3.interpolateReds)\n        //.domain([0, d3.max(D.flat().flat().map(d => d.dur).flat(), d => d[2] - d[0])]);\n        .domain([0, 10000]);\n\n    let c = (x) => x < 100 ? \"lightslategray\" : x > 10000 ? \"url(#none)\" : C(x);\n    let lc = (lib) => {\n        return {\n            \"druid\": \"mediumseagreen\",\n            \"sklearn\": \"orange\",\n            \"js\": \"slateblue\",\n            \"dr_sk\": \"url(#dr_sk)\",\n            \"dr_js\": \"url(#dr_js)\",\n            \"sk_js\": \"url(#sk_js)\",\n            \"none\": \"url(#none)\",\n        }[lib];\n    }\n\n    let svgs = []\n    const steps = 20;\n    const lim = 6000;\n\n\n    function download_svgs() {\n        let nest = d3.nest().key(d => d.DR).entries(D);\n        for (let i = 0; i < nest.length; ++i) {\n            let filename = `eval_${nest[i].key}.svg`\n            download(svgs[i].outerHTML, filename);\n        }\n    }\n\n    function winner(dr, sk, js, d, n) {\n        //console.log(dr, sk, js, d, n)\n        let values = [dr, sk, js]\n            .filter(D => D) // remove not existing\n            .map(D => { // select d and n\n                //console.log(D)\n                if (D.length < d) return undefined;\n                const row = D[d].filter(d => d)\n                if (row.length <= n) return undefined;\n                const col = row[n];\n                return col.dur.map(d => [d[2] - d[0], D.LIB.slice(0, 2)]);\n            })\n            .filter(D => D) // remoove undefineds\n            .flat()\n            .filter(d => d[0] < 10000)\n\n        if (values.length == 0) return \"none\"\n        let [f, s, ...rest] = values\n            //.filter(d => d[0] > 10000)\n            .sort((a, b) => d3.ascending(a[0] || null, b[0] || null));\n        switch (f[1] + s[1]) {\n            case \"sksk\": return \"sklearn\";\n            case \"skdr\":\n            case \"drsk\":\n                return \"dr_sk\";\n            case \"drdr\": return \"druid\";\n            case \"drjs\":\n            case \"jsdr\":\n                return \"dr_js\";\n            case \"jsjs\": return \"js\";\n            case \"skjs\":\n            case \"jssk\":\n                return \"sk_js\";\n            default: return \"none\";\n        }\n    }\n</script>\n\n{#each d3.nest().key(d => d.DR).entries(D) as d, i}\n    <svg bind:this={svgs[i]} width={margin.left + 31 * (W + wm) + margin.right} height={margin.top + d.values.length * (H + m) + margin.bottom}>\n        <defs>\n            <pattern id=\"none\"\n                x=\"0\" y=\"0\" width=\"6.356382351524142\" height=\"6.356382351524142\"\n                patternUnits=\"userSpaceOnUse\">\n                <path\n                    style=\"stroke:#333;stroke-width:1px\"\n                    d=\"M 2.5768547924690237,-3.7795275590551185 10.135909910579262,3.7795275590551185\"/>\n                <path\n                    style=\"stroke:#333;stroke-width:1px\"\n                    d=\"M -3.7795275590551185,-3.7795275590551185 10.135909910579262,10.135909910579262\"/>\n                <path\n                    style=\"stroke:#333;stroke-width:1px\"\n                    d=\"M -3.7795275590551185,2.5768547924690237 3.7795275590551185,10.135909910579262\"/>\n            </pattern>\n            <marker id=\"arrow\" markerWidth=\"10\" markerHeight=\"10\" refX=\"0\" refY=\"3\" orient=\"auto\" markerUnits=\"strokeWidth\">\n                <path d=\"M0,0 L0,6 L9,3 z\" fill=\"#000\" />\n            </marker>\n            <pattern id=\"dr_sk\" patternUnits=\"userSpaceOnUse\" width=\"6\" height=\"6\" patternTransform=\"rotate(-45)\">\n                <line x1=\"0\" y=\"0\" x2=\"0\" y2=\"6\" stroke={lc(\"sklearn\")} stroke-width=\"6\" />\n                <line x1=\"6\" y=\"0\" x2=\"6\" y2=\"6\" stroke={lc(\"druid\")} stroke-width=\"6.1\" />\n            </pattern>\n            <pattern id=\"dr_js\" patternUnits=\"userSpaceOnUse\" width=\"6\" height=\"6\" patternTransform=\"rotate(-45)\">\n                <line x1=\"0\" y=\"0\" x2=\"0\" y2=\"6\" stroke={lc(\"js\")} stroke-width=\"6\" />\n                <line x1=\"6\" y=\"0\" x2=\"6\" y2=\"6\" stroke={lc(\"druid\")} stroke-width=\"6.1\" />\n            </pattern>\n            <pattern id=\"sk_js\" patternUnits=\"userSpaceOnUse\" width=\"6\" height=\"6\" patternTransform=\"rotate(-45)\">\n                <line x1=\"0\" y=\"0\" x2=\"0\" y2=\"6\" stroke={lc(\"js\")} stroke-width=\"6\" />\n                <line x1=\"6\" y=\"0\" x2=\"6\" y2=\"6\" stroke={lc(\"sklearn\")} stroke-width=\"6.1\" />\n            </pattern>\n        </defs>\n        <text x={margin.left} y={28} text-anchor=\"start\" dominant-baseline=\"central\" font-size=\"1.3em\">{d.key}</text>\n        <g transform=\"translate({margin.left + 31 * (W + wm)}, {15})\">\n            {#each d3.range(steps) as t}\n                <g transform=\"translate({-(steps-t) * (W + wm)}, 0)\">\n                    <rect\n                        width={W}\n                        height={W}\n                        fill={c(100 + (C.domain()[1] - 100) / steps * t)}>\n                    </rect>\n                    <g transform=\"translate({W/2}, {W/2}) rotate(45)\">\n                        <text style=\"pointer-events: none;\"\n                            text-anchor=\"middle\"\n                            dominant-baseline=\"central\"\n                            font-family=\"Courier Prime\"\n                            font-size=\"0.6em\"\n                            font-weight=800\n                            fill={(100 + (C.domain()[1] -100) / steps * t) > lim ? \"white\" : \"#333\"}>\n                            {d3.format(\".0f\")(100 + (C.domain()[1] -100) / steps * t)}</text>\n                    </g>\n                </g>\n            {/each}\n                <g transform=\"translate({-(steps+1) * (W + wm)}, 0)\">\n                    <rect\n                        width={W}\n                        height={W}\n                        fill={c(0)}>\n                    </rect>\n                    <g transform=\"translate({W/2}, {W/2}) rotate(45)\">\n                        <text style=\"pointer-events: none;\"\n                            text-anchor=\"middle\"\n                            dominant-baseline=\"central\"\n                            font-family=\"Courier Prime\"\n                            font-size=\"0.6em\"\n                            font-weight=800\n                            fill=\"white\">\n                            &leq;100</text>\n                    </g>\n                </g>\n                <g transform=\"translate({-(steps+1) * (W + wm) - 5}, {W/2})\">\n                    <text text-anchor=\"end\" dominant-baseline=\"middle\" font-size=20 font-family=\"Courier Prime\">t/ms:</text>\n                </g>\n        </g>\n        <!-- Comp -->\n        <g transform=\"translate({margin.left}, {margin.top2})\">\n\n        <g transform=\"translate({-15}, {25}) rotate(-90)\">\n            <line x1={-20} x2={-10} stroke=\"black\"></line>\n            <line x1={10} x2={20} stroke=\"black\" marker-end=\"url(#arrow)\"></line>\n            <text text-anchor=\"middle\" dominant-baseline=\"middle\" font-size=20 font-family=\"Courier Prime\">D</text>\n        </g>\n            {#each d3.range(8) as i}\n                {#each d3.range(31) as j} \n                    <rect\n                        x={j * (W + wm)}\n                        y={(7-i) * (ch)}\n                        width={W}\n                        height={ch}\n                        fill={lc(winner(d.values.find(d => d.LIB == \"druid\"), d.values.find(d => d.LIB == \"sklearn\"), d.values.find(d => d.LIB == \"js\"), i, j))}>\n                    </rect>\n                {/each}\n            {/each}\n        </g>\n        <!-- Eval -->\n        {#each d.values as librow, k}\n            <g transform=\"translate({margin.left}, {margin.top + k * (H+m)})\">\n                <g transform=\"translate(-60, {(9 * (h + hm)) /2}) rotate(-90)\">\n                    <text text-anchor=\"end\" dominant-baseline=\"central\" font-size=\"1.3em\" font-family=\"Courier Prime\">{librow.LIB}</text>\n                    <circle cx=15 r=10 fill={lc(librow.LIB)}></circle>\n                </g>\n                {#each librow as row, l}\n                    <g transform=\"translate(-5, {(8 - l) * (h + hm) + h / 2})\">\n                        <text dominant-baseline=\"central\" text-anchor=\"end\" font-family=\"Courier Prime\">{Math.floor(2 * 5 ** ((l + 1) / 2))}</text>\n                    </g>\n                    {#each d3.range(31).map(y => row[y] || 0) as col, j}\n                        <rect class:data={!computing}\n                            width={W}\n                            height={h}\n                            x={j * (W + wm)}\n                            y={(8 - l) * (h+hm)}\n                            fill={col ? c(d3.mean(col.dur, d => d[2] - d[0])) : \"url(#none)\"}\n                            on:click={dispatch(\"select\", {\n                                    \"d\": col.d,\n                                    \"n\": col.n,\n                                    \"dr\": librow.DR,\n                                })}\n                        >\n                            <title>{col ? d3.format(\".2f\")(d3.mean(col.dur, d => d[2] - d[0])) + \"ms\" : \"\"}</title>\n                        </rect>\n                        {#if col && d3.mean(col.dur, d => d[2] - d[0]) < 10000 }\n                            <g transform=\"translate({j * (W + wm) + W/2}, {(8 - l) * (h+hm) + h/2}) rotate(45) scale(1, 1)\">\n                            <text style=\"pointer-events: none;\"\n                                text-anchor=\"middle\"\n                                dominant-baseline=\"central\"\n                                font-family=\"Courier Prime\"\n                                font-size=\"0.6em\"\n                                font-weight=800\n                                fill={((d3.mean(col.dur, d => d[2] - d[0])) > lim || (d3.mean(col.dur, d => d[2] - d[0])) < 100) ? \"white\" : \"#333\"}\n                                >\n                                {d3.format(\".0f\")(d3.mean(col.dur, d => d[2] - d[0]))}\n                            </text>\n                            </g>\n                        {/if}\n                    {/each}\n                {/each}\n            </g>\n        {/each}\n        <g transform=\"translate({margin.left}, {margin.top + d.values.length * (H + m)})\">\n            {#each d3.range(31).map(j => d.values[0][0][j] || {n: Math.floor(16 + 2 ** ((j+1)/2 + 1))}) as col, j}\n                <g transform=\"translate({(j * (W+wm) + W/2)}, 5) rotate(60)\">\n                    <text dominant-baseline=\"central\" font-family=\"Courier Prime\">{col.n}</text>\n                </g>\n            {/each}\n        </g>\n        <g transform=\"translate({margin.left - 35}, {margin.top + d.values.length * (H + m) - 20}) rotate(-90)\">\n            <line x1={-30} x2={-10} stroke=\"black\"></line>\n            <line x1={10} x2={30} stroke=\"black\" marker-end=\"url(#arrow)\"></line>\n            <text text-anchor=\"middle\" dominant-baseline=\"middle\" font-size=20 font-family=\"Courier Prime\">D</text>\n        </g>\n\n\n        <g transform=\"translate({margin.left + 20}, {margin.top + d.values.length * (H + m) + 35})\">\n            <line x1={-30} x2={-10} stroke=\"black\"></line>\n            <line x1={10} x2={30} stroke=\"black\" marker-end=\"url(#arrow)\"></line>\n            <text text-anchor=\"middle\" dominant-baseline=\"middle\" font-size=20 font-family=\"Courier Prime\">N</text>\n        </g>\n\n        \n    </svg>\n    <br>\n{/each}\n\n<style>\n    rect.data:hover {\n        stroke: black;\n        stroke-width: 2px;\n    }\n\n    rect.data:active {\n        stroke: blue;\n        stroke-width: 4px;\n    }\n\n    rect.data:active +g {\n        font-size: 2em;\n    }\n    rect {\n        transition: stroke 300ms ease-in-out;\n        transition: stroke-width .30s ease-in-out;\n    }\n\n    text {\n        transition: font-size 300ms ease-in-out;\n    }\n</style>"
  ],
  "names": [],
  "mappings": "AAuVS,GAAG,AAAE,CAAC,AACP,gBAAgB,CAAE,OAAO,AAC7B,CAAC,AAED,KAAK,cAAC,CAAC,AACH,QAAQ,CAAE,KAAK,CACf,GAAG,CAAE,IAAI,CACT,KAAK,CAAE,IAAI,AAEf,CAAC,AAED,OAAO,cAAC,CAAC,AACL,aAAa,CAAE,KAAK,AACxB,CAAC;ACnGD,IAAI,oBAAK,MAAM,AAAC,CAAC,AACb,MAAM,CAAE,KAAK,CACb,YAAY,CAAE,GAAG,AACrB,CAAC,AAED,IAAI,oBAAK,OAAO,AAAC,CAAC,AACd,MAAM,CAAE,IAAI,CACZ,YAAY,CAAE,GAAG,AACrB,CAAC,AAED,IAAI,KAAK,OAAO,CAAE,CAAC,eAAC,CAAC,AACjB,SAAS,CAAE,GAAG,AAClB,CAAC,AACD,IAAI,eAAC,CAAC,AACF,UAAU,CAAE,MAAM,CAAC,KAAK,CAAC,WAAW,CACpC,UAAU,CAAE,YAAY,CAAC,IAAI,CAAC,WAAW,AAC7C,CAAC,AAED,IAAI,eAAC,CAAC,AACF,UAAU,CAAE,SAAS,CAAC,KAAK,CAAC,WAAW,AAC3C,CAAC"
}