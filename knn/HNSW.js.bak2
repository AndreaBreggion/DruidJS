import * as metric from '../metrics/index';
import { Heap } from '../datastructure/Heap';

const euclidean = metric.euclidean;

export class HNSW {
    /**
     * 
     * @param {*} metric metric to use: (a, b) => distance
     * @param {*} heuristic use heuristics or naive selection
     * @param {*} m max number of connections
     * @param {*} ef size of candidate list
     * @param {*} m0 max number of connections for ground layer 
     */
    constructor(metric = euclidean, heuristic = true, m = 5, ef = 200, m0 = null) {
        this._metric = metric;
        this._select = heuristic ? this._select_heuristic : this._select_simple;
        this._m = m;
        this._ef = ef;
        this._m0 = m0 || 2 * m;
        this._graph = {};
        this._data = [];
        this._ep = null;
        this._L = null;
        this._mL = 1 / Math.log2(m);
    }

    add(...elements) {
        let metric = this._metric;
        let m = this._m;
        let ef = this._ef;
        let m0 = this._m0;
        let graph = this._graph;
        let data = this._data;
        let mL = this._mL;
        for (let element of elements) {
            //element = new Point(element, undefined);
            let W = [];
            let ep = this._ep;
            let L = this._L;
            //let idx = data.length;
            //data.push(element)
            let l = Math.floor(-Math.log(Math.random() * mL)) + 1
            let layers = [];
            //graph.keys().forEach(k => layers.push(k))
            for (let k of Object.keys(graph)) {
                layers.push(k)
            }
            layers = layers.sort((a, b) => b - a);
            let min_L_l = Math.min(L, l);
            for (let l_c of layers.filter(l_c => l_c >= min_L_l)) {
                W = graph[l_c].search(element, ep, 1);
                ep = W;
            }
            for (let l_c of layers.filter(l_c => l_c < min_L_l)) {
                let layer_c = graph[l_c]
                let new_point = new Point(element, l_c);
                new_point.addLayer(l_c, layer_c)
                W = layer_c.search(element, ep, ef);
                layer_c.add(new_point);
                let neighbors = this._select(element, W, m, l_c);
                neighbors.forEach(p => {
                    p.addEdge(new_point).addLayer(l_c, layer_c)
                    new_point.addEdge(p).addLayer(l_c, layer_c)
                });
                for (let e of neighbors) {
                    let eConn = e.neighborhood.filter(q => q.isInLayer(l_c));
                    let max = (l_c === 0 ? m0 : m);
                    if (eConn.length > max) {
                        e.neighborhood = this._select(e, eConn, max, l_c);
                    }
                }
                ep = W;
            }
            /*if (!this._L || l > L) {
                let new_layer = new Layer(m, l, metric);
                let q = new Point(element, l)
                q.addLayer(l, new_layer)
                new_layer.add(q);
                this._ep = new_layer.entry_points;
                this._L = l;
                graph.set(l, new_layer);
            }*/
            if (Object.keys(graph).length == 0 || Object.keys(graph).length < l || l > L) {
                let q = new Point(element, l)
                for (let i = l, n = Object.keys(graph).length; i >= n; --i) {
                    let new_layer = new Layer(m, i, metric);
                    q.addLayer(i, new_layer)
                    new_layer.add(q);
                    graph[i] = new_layer;
                    if (i === l) {
                        this._ep = new_layer.entry_points;
                        this._L = l;
                    }
                }
            }
        }
        return this;
    }

    _select_heuristic(q, C, M, l_c, extendCandidates = true, keepPrunedConnections = true) {
        const metric = this._metric;
        let R = [];
        let W_set = new Set();
        C.forEach(c => W_set.add(c));
        if (extendCandidates) {
            for (let e of C) {
                for (let e_adj of e.neighborhood.filter(l => l.isInLayer(l_c))) {
                    if (!W_set.has(e_adj)) {
                        W_set.add(e_adj)
                    }
                }
            }
        }
        let W = new Heap(Array.from(W_set), d => metric(d.point, q), "min")
        let W_d = new Heap(null, d => metric(d.point, q), "min");
        while (W.first && R.length < M) {
            let e = W.pop()
            if (R.length === 0 || e.value < R[Math.floor(Math.random() * (R.length - 1))].point) {
                R.push(e.element);
            } else {
                W_d.push(e.element)
            }
        }
        if (keepPrunedConnections) {
            while (W_d.first && R.length < M) {
                R.push(W_d.pop().element)
            }
        }
        return R
    }

    _select_simple(q, C, M) {
        const metric = this._metric;
        let res = C.sort((a,b) => metric(a.point, q) - metric(b.point, q)).slice(0,M);
        return res
    }

    search(q, K, ef = null) {
        ef = ef || this._ef;
        const metric = this._metric;
        let graph = this._graph;
        let W = [];
        let ep = this._ep;
        let L = this._L;
        /*let layers = [];
        //graph.keys().forEach(k => layers.push(k))
        for (let k of Object.keys(graph)) {
            layers.push(k)
        }
        layers = layers.sort((a, b) => b - a);*/
        for (let l_c of Object.keys(graph).filter(l_c => l_c > 0)) {
            let layer = graph[l_c];
            W = layer.search(q, ep, 1)
            ep = W
        }
        let layer0 = graph[0]
        W = layer0.search(q, ep, ef);
        return W.slice(0,K).map(p => p.point)
    }
}

class Layer {
    constructor(m, l_c, metric) {
        this.m = m;
        this.l_c = l_c;
        this.points = [];
        this.metric = metric;
    }

    add(p) {
        this.points.push(p)
        return this;
    }

    search(q, ep, ef) {
        const metric = this.metric;
        const l_c = this.l_c;
        let v = new Set();
        ep.forEach(p => v.add(p))
        let C = new Heap(ep, d => metric(d.point, q), "min");
        //console.log(C.toArray().map(d => d.point))
        let W = new Heap(ep, d => metric(d.point, q), "max");
        //console.log(W.toArray().map(d => d.point))
        while (C.length > 0) {
            let c = C.pop();
            let f = W.first;
            if (c.value > f.value) {
                break;
            }
            for (let e of c.element.neighborhood.filter(l => l.isInLayer(l_c))) {
                if (!v.has(e)) {
                    v.add(e);
                    f = W.first.element;
                    if (metric(e.point, q) < metric(f.point, q) || W.length < ef) {
                        C.push(e);
                        //W.pop();
                        W.push(e);
                        if (W.length > ef) {
                            W.pop();
                        }
                    }
                }
            }
        }
        //console.log(q, ...W.toArray().map(p => p.point))
        return W.toArray().reverse();
    }


    get length() {
        return points.length;
    }

    get number() {
        return this.l_c;
    }

    get entry_points() {
        return this.points;
    }
}

class Point {
    constructor(p, layer_number) {
        this.p = p;
        this.edges = [];
        this.layers = {};
        this.layer_number = layer_number
    }

    get point() {
        return this.p;
    }

    addEdge(q) {
        this.edges.push(q);
        return this;
    }

    removeEdge(q) {
        this.edges.remove(q);
    }

    get neighborhood() {
        return this.edges;
    }

    set neighborhood(edges) {
        this.edges = edges;
    }

    addLayer(l, layer) {
        this.layers[l] = layer;
        return this;
    }

    isInLayer(l) {
        return l in this.layers;
    }

    removeLayer(l) {
        this.layers.remove(l);
    }

    set level(l_c) {
        this.layer_number = l_c;
    }

    get level() {
        return this.layer_number;
    }


}