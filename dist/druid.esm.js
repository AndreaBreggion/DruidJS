function t(t,e){return Math.sqrt(s(t,e))}function e(t){let e,r,s=t.length,i=0,n=0;for(let o=0;o<s;++o)e=t[o]-n,r=i+e,n=r-i-e,i=r;return i}function r(t){let e=t.length,r=0,s=0;for(let i=0;i<e;++i){let e=t[i],n=r+e;Math.abs(r)>=Math.abs(e)?s+=r-n+e:s+=e-n+r,r=n}return r+s}function s(t,e){if(t.length!=e.length)return;let s=t.length,i=new Array(s);for(let r=0;r<s;++r){let s=t[r],n=e[r];i[r]=(s-n)*(s-n)}return r(i)}function i(t,e){if(t.length!==e.length)return;let r=t.length,s=0,i=0,n=0;for(let o=0;o<r;++o)s+=t[o]*e[o],i+=t[o]*t[o],n+=e[o]*e[o];return Math.acos(s/(Math.sqrt(i)*Math.sqrt(n)))}function n(t,e){if(t.length!=e.length)return;let r=t.length,s=0;for(let i=0;i<r;++i)s+=Math.abs(t[i]-e[i]);return s}function o(t,e){if(t.length!=e.length)return;let r=t.length,s=[];for(let i=0;i<r;++i)s.push(Math.abs(t[i]-e[i]));return Math.max(...s)}function a(t,e){if(t.length!==e.length)return;let r=t.length,s=0;for(let i=0;i<r;++i)s+=Math.abs(t[i]-e[i])/(Math.abs(t[i])+Math.abs(e[i]));return s}function h(e,r,s=null,i=t){let n=e.length,o=s||l(e,i);for(let t=0;t<n;++t)o[t]=o[t].map(((e,r)=>({i:t,j:r,distance:o[t][r]}))).sort(((t,e)=>t.distance-e.distance)).slice(1,r+1);return o}function l(e,r=t){if(void 0===r)return;let s=e.length,i=new Array(s);for(let t=0;t<s;++t)i[t]=new Array(s);for(let t=0;t<s;++t)for(let n=t+1;n<s;++n)i[t][n]=i[n][t]=r(e[t],e[n]);return i}function _(t,e,r=null){if(r||(r=Math.max(Math.round(e-t)+1,1)),r<2)return 1===r?[t]:[];let s=new Array(r);for(let i=r-=1;i>=0;--i)s[i]=(i*e+(r-i)*t)/r;return s}function c(e,r=t){let s=null;if(e instanceof u){let[t,r]=e.shape;if(1===t)s=e.row(0);else{if(1!==r)throw"matrix must be 1d!";s=e.col(0)}}else s=e;let i=s.length,n=new Array(i);return n.fill(0),r(s,n)}class u{constructor(t=null,e=null,r=null){if(this._rows=t,this._cols=e,this._data=null,t&&e){if(!r)return this._data=new Float64Array(t*e),this;if("function"==typeof r){this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r(s,t);return this}if("string"==typeof r){if("zeros"===r)return new u(t,e,0);if("identity"===r||"I"===r){this._data=new Float64Array(t*e);for(let r=0;r<t;++r)this._data[r*e+r]=1;return this}if("center"===r&&t==e){this._data=new Float64Array(t*e),r=(e,r)=>(e===r?1:0)-1/t;for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r(s,t);return this}}if("number"==typeof r){this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r;return this}}return this}static from(t,e="row"){if(t instanceof u)return t.clone();if(!(Array.isArray(t)||t instanceof Float64Array)){if("number"==typeof t)return new u(1,1,t);throw"error"}{let r=t.length;if(0===r)throw"Array is empty";if(!(Array.isArray(t[0])||t[0]instanceof Float64Array)){if("row"===e)return new u(1,r,((e,r)=>t[r]));if("col"===e)return new u(r,1,(e=>t[e]));if("diag"===e)return new u(r,r,((e,r)=>e==r?t[e]:0));throw"1d array has NaN entries"}if(Array.isArray(t[0])||t[0]instanceof Float64Array){let e=t[0].length;for(let s=0;s<r;++s)if(t[s].length!==e)throw"various array lengths";return new u(r,e,((e,r)=>t[e][r]))}}}row(t){let e=new Array(this._cols);for(let r=0;r<this._cols;++r)e[r]=this._data[t*this._cols+r];return e}*iterate_rows(){const t=this._cols,e=this._rows,r=this._data;for(let s=0;s<e;++s)yield r.subarray(s*t,(s+1)*t)}[Symbol.iterator]=this.iterate_rows;set_row(t,e){let r=this._cols;if(Array.isArray(e)&&e.length===r){let s=t*r;for(let t=0;t<r;++t)this._data[s+t]=e[t]}else if(e instanceof u&&e.shape[1]===r&&1===e.shape[0]){let s=t*r;for(let t=0;t<r;++t)this._data[s+t]=e._data[t]}return this}col(t){let e=new Array(this._rows);for(let r=0;r<this._rows;++r)e[r]=this._data[r*this._cols+t];return e}entry(t,e){return this._data[t*this._cols+e]}set_entry(t,e,r){return this._data[t*this._cols+e]=r,this}transpose(){return new u(this._cols,this._rows,((t,e)=>this.entry(e,t)))}get T(){return this.transpose()}inverse(){const t=this._rows,e=this._cols;let r=new u(t,2*e,((t,r)=>r>=e?t===r-e?1:0:this.entry(t,r))),s=0,i=0;for(;s<t&&i<e;){var n=0;let o=-1/0;for(let e=s;e<t;++e){let t=Math.abs(r.entry(e,i));o<t&&(n=e,o=t)}if(0==r.entry(n,i))i++;else{for(let t=0;t<2*e;++t){let e=r.entry(s,t),i=r.entry(n,t);r.set_entry(s,t,e),r.set_entry(n,t,i)}for(let n=s+1;n<t;++n){let t=r.entry(n,i)/r.entry(s,i);r.set_entry(n,i,0);for(let o=i+1;o<2*e;++o)r.set_entry(n,o,r.entry(n,o)-r.entry(s,o)*t)}s++,i++}}for(let s=0;s<t;++s){let t=r.entry(s,s);for(let i=s;i<2*e;++i)r.set_entry(s,i,r.entry(s,i)/t)}for(let s=t-1;s>=0;--s){let t=r.entry(s,s);for(let i=0;i<s;i++){let n=r.entry(i,s)/t;for(let t=i;t<2*e;++t){let e=r.entry(i,t);e-=r.entry(s,t)*n,r.set_entry(i,t,e)}}}return new u(t,e,((t,s)=>r.entry(t,s+e)))}dot(t){if(t instanceof u){let e=this;if(e.shape[1]!==t.shape[0])throw`A.dot(B): A is a ${e.shape.join(" x ")}-Matrix, B is a ${t.shape.join(" x ")}-Matrix: \n                A has ${e.shape[1]} cols and B ${t.shape[0]} rows. \n                Must be equal!`;let s=e.shape[1];return new u(e.shape[0],t.shape[1],((i,n)=>{let o=e.row(i),a=t.col(n);for(let t=0;t<s;++t)o[t]*=a[t];return r(o)}))}if(Array.isArray(t)||t instanceof Float64Array){let e=this._rows;if(t.length!==e)throw`A.dot(B): A has ${e} cols and B has ${t.length} rows. Must be equal!`;let s=new Array(e);for(let i=0;i<e;++i)s[i]=r(this.row(i).map((e=>e*t[i])));return s}throw"B must be Matrix or Array"}outer(t){let e=this,r=e._data.length;if(r!=t._data.length)return;let s=new u;return s.shape=[r,r,(r,i)=>r<=i?e._data[r]*t._data[i]:s.entry(i,r)],s}concat(t,e="horizontal"){const r=this,[s,i]=r.shape,[n,o]=t.shape;if("horizontal"==e){if(s!=n)throw`A.concat(B, "horizontal"): A and B need same number of rows, A has ${s} rows, B has ${n} rows.`;const e=new u(s,i+o,"zeros");return e.set_block(0,0,r),e.set_block(0,i,t),e}if("vertical"==e){if(i!=o)throw`A.concat(B, "vertical"): A and B need same number of columns, A has ${i} columns, B has ${o} columns.`;const e=new u(s+n,i,"zeros");return e.set_block(0,0,r),e.set_block(s,0,t),e}if("diag"==e){const e=new u(s+n,i+o,"zeros");return e.set_block(0,0,r),e.set_block(s,i,t),e}throw`type must be "horizontal" or "vertical", but type is ${e}!`}set_block(t,e,r){let[s,i]=r.shape;for(let n=0;n<s;++n)if(!(n>this._rows))for(let s=0;s<i;++s)s>this._cols||this.set_entry(n+t,s+e,r.entry(n,s));return this}get_block(t,e,r=null,s=null){const[i,n]=this.shape;if(s=s||n,(r=r||i)<=t||s<=e)throw`\n                end_row must be greater than start_row, and \n                end_col must be greater than start_col, but\n                end_row = ${r}, start_row = ${t}, end_col = ${s}, and start_col = ${e}!`;const o=new u(r-t,s-e,"zeros");for(let i=t,n=0;i<r;++i,++n)for(let t=e,r=0;t<s;++t,++r)o.set_entry(n,r,this.entry(i,t));return o}_apply_array(t,e){const r=this._data,[s,i]=this.shape;for(let n=0;n<s;++n){const s=n*i;for(let o=0;o<i;++o){const i=s+o,a=r[i];r[i]=t(a,e(n,o))}}return this}_apply_rowwise_array(t,e){return this._apply_array(e,((e,r)=>t[r]))}_apply_colwise_array(t,e){const r=this._data,[s,i]=this.shape;for(let n=0;n<s;++n){const s=n*i;for(let o=0;o<i;++o){const i=s+o,a=r[i];r[i]=e(a,t[n])}}return this}_apply(t,e){let r=this._data;if(t instanceof u){let[s,i]=t.shape,[n,o]=this.shape;if(1===s){if(o!==i)throw"cols !== value_cols";for(let s=0;s<n;++s)for(let i=0;i<o;++i)r[s*o+i]=e(r[s*o+i],t.entry(0,i))}else if(1===i){if(n!==s)throw"rows !== value_rows";for(let s=0;s<n;++s)for(let i=0;i<o;++i)r[s*o+i]=e(r[s*o+i],t.entry(s,0))}else{if(n!=s||o!=i)throw"error";for(let s=0;s<n;++s)for(let i=0;i<o;++i)r[s*o+i]=e(r[s*o+i],t.entry(s,i))}}else if(Array.isArray(t)){let s=this._rows,i=this._cols;if(t.length===s)for(let n=0;n<s;++n)for(let s=0;s<i;++s)r[n*i+s]=e(r[n*i+s],t[n]);else{if(t.length!==i)throw"error";for(let n=0;n<s;++n)for(let s=0;s<i;++s)r[n*i+s]=e(r[n*i+s],t[s])}}else for(let s=0,i=this._rows*this._cols;s<i;++s)r[s]=e(r[s],t);return this}clone(){let t=new u;return t._rows=this._rows,t._cols=this._cols,t._data=this._data.slice(0),t}mult(t){return this.clone()._apply(t,((t,e)=>t*e))}divide(t){return this.clone()._apply(t,((t,e)=>t/e))}add(t){return this.clone()._apply(t,((t,e)=>t+e))}sub(t){return this.clone()._apply(t,((t,e)=>t-e))}get shape(){return[this._rows,this._cols]}set shape([t,e,r=(()=>0)]){this._rows=t,this._cols=e,this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r(s,t);return this}get to2dArray(){const t=this._rows,e=this._cols;let r=new Array(t);for(let s=0;s<t;++s){let t=new Array(e);for(let r=0;r<e;++r)t[r]=this.entry(s,r);r[s]=t}return r}get diag(){const t=this._rows,e=this._cols,r=Math.min(t,e);let s=new Array(r);for(let t=0;t<r;++t)s[t]=this.entry(t,t);return s}get mean(){const t=this._data,e=this._rows*this._cols;let r=0;for(let s=0;s<e;++s)r+=t[s];return r/e}get meanRows(){const t=this._data,e=this._rows,r=this._cols;let s=[];for(let i=0;i<e;++i){s[i]=0;for(let e=0;e<r;++e)s[i]+=t[i*r+e];s[i]/=r}return s}get meanCols(){const t=this._data,e=this._rows,r=this._cols;let s=[];for(let i=0;i<r;++i){s[i]=0;for(let n=0;n<e;++n)s[i]+=t[n*r+i];s[i]/=e}return s}static solve_CG(t,e,r,s=.001){const i=t.shape[0],n=e.shape[1];let o=new u(i,0);for(let a=0;a<n;++a){let n=new u(i,1,(()=>r.random)),h=u.from(e.col(a)).T.sub(t.dot(n)),l=h.clone();do{const e=t.dot(l),r=h.T.dot(h).entry(0,0)/l.T.dot(e).entry(0,0);n=n.add(l.mult(r));const s=h.sub(e.mult(r)),i=s.T.dot(s).entry(0,0)/h.T.dot(h).entry(0,0);l=s.add(l.mult(i)),h=s}while(Math.abs(h.mean)>s);o=o.concat(n,"horizontal")}return o}static solve(t,e){let{L:r,U:s}="L"in t&&"U"in t?t:u.LU(t),i=r.shape[0],n=e.clone();for(let t=0;t<i;++t){for(let e=0;e<t-1;++e)n.set_entry(0,t,n.entry(0,t)-r.entry(t,e)*n.entry(1,e));n.set_entry(0,t,n.entry(0,t)/r.entry(t,t))}for(let t=i-1;t>=0;--t){for(let e=i-1;e>t;--e)n.set_entry(0,t,n.entry(0,t)-s.entry(t,e)*n.entry(0,e));n.set_entry(0,t,n.entry(0,t)/s.entry(t,t))}return n}static LU(t){const e=t.shape[0],r=new u(e,e,"zeros"),s=new u(e,e,"identity");for(let i=0;i<e;++i){for(let n=i;n<e;++n){let e=0;for(let t=0;t<i;++t)e+=r.entry(n,t)*s.entry(t,i);r.set_entry(n,i,t.entry(n,i)-e)}for(let n=i;n<e;++n){if(0===r.entry(i,i))return;let e=0;for(let t=0;t<i;++t)e+=r.entry(i,t)*s.entry(t,n);s.set_entry(i,n,(t.entry(i,n)-e)/r.entry(i,i))}}return{L:r,U:s}}static SVD(t,e=2){const r=M.T;let s=r.dot(M),i=M.dot(r),{eigenvectors:n,eigenvalues:o}=simultaneous_poweriteration(s,e),{eigenvectors:a}=simultaneous_poweriteration(i,e);return{U:a,Sigma:o.map((t=>Math.sqrt(t))),V:n}}}class f{constructor(t){return this._N=624,this._M=397,this._MATRIX_A=2567483615,this._UPPER_MASK=2147483648,this._LOWER_MASK=2147483647,this._mt=new Array(this._N),this._mti=this.N+1,this.seed=t||(new Date).getTime(),this}set seed(t){this._seed=t;let e=this._mt;for(e[0]=t>>>0,this._mti=1;this._mti<this._N;this._mti+=1){let t=this._mti,r=e[t-1]^e[t-1]>>>30;e[t]=(1812433253*((4294901760&r)>>>16)<<16)+1812433253*(65535&r)+t,e[t]>>>=0}}get seed(){return this._seed}get random(){return this.random_int*(1/4294967296)}get random_int(){let t,e=new Array(0,this._MATRIX_A);if(this._mti>=this._N){let r;this._mti==this._N+1&&(this.seed=5489);let s=this._N-this._M,i=this._M-this._N;for(r=0;r<s;++r)t=this._mt[r]&this._UPPER_MASK|this._mt[r+1]&this._LOWER_MASK,this._mt[r]=this._mt[r+this._M]^t>>>1^e[1&t];for(;r<this._N-1;++r)t=this._mt[r]&this._UPPER_MASK|this._mt[r+1]&this._LOWER_MASK,this._mt[r]=this._mt[r+i]^t>>>1^e[1&t];t=this._mt[this._N-1]&this._UPPER_MASK|this._mt[0]&this._LOWER_MASK,this._mt[this._N-1]=this._mt[this._M-1]^t>>>1^e[1&t],this._mti=0}return t=this._mt[this._mti+=1],t^=t>>>11,t^=t<<7&2636928640,t^=t<<15&4022730752,t^=t>>>18,t>>>0}choice(t,e){if(t instanceof u){let[r,s]=t.shape;if(e>r)throw"n bigger than A!";let i=new Array(e),n=_(0,r-1);for(let t=0,r=n.length;t<e;++t,--r){let e=this.random_int%r;i[t]=n.splice(e,1)[0]}return i.map((e=>t.row(e)))}if(Array.isArray(t)||t instanceof Float64Array){let r=t.length;if(e>r)throw"n bigger than A!";let s=new Array(e),i=_(0,r-1);for(let t=0,r=i.length;t<e;++t,--r){let e=this.random_int%r;s[t]=i.splice(e,1)[0]}return s.map((e=>t[e]))}}static choice(t,e,r=19870307){let[s,i]=t.shape;if(e>s)throw"n bigger than A!";let n=new f(r),o=new Array(e),a=_(0,s-1);for(let t=0,r=a.length;t<e;++t,--r){let e=n.random_int%r;o[t]=a.splice(e,1)[0]}return o.map((e=>t.row(e)))}}class p{constructor(t=null,e=(t=>t),r="min"){return t?p.heapify(t,e,r):(this._accessor=e,this._container=[],this._comparator="min"==r?(t,e)=>t<e:"max"==r?(t,e)=>t>e:r,this)}static heapify(t,e=(t=>t),r="min"){const s=new p(null,e,r),i=s._container;for(const r of t)i.push({element:r,value:e(r)});for(let e=Math.floor(t.length/2-1);e>=0;--e)s._heapify_down(e);return s}_swap(t,e){const r=this._container;[r[e],r[t]]=[r[t],r[e]]}_heapify_up(){const t=this._container;let e=t.length-1;for(;e>0;){let r=Math.floor((e-1)/2);if(!this._comparator(t[e].value,t[r].value))break;this._swap(r,e),e=r}}push(t){const e={element:t,value:this._accessor(t)};return this._container.push(e),this._heapify_up(),this}_heapify_down(t=0){const e=this._container,r=this._comparator,s=e.length;let i=2*t+1,n=2*t+2,o=t;if(o>s)throw"index higher than length";i<s&&r(e[i].value,e[o].value)&&(o=i),n<s&&r(e[n].value,e[o].value)&&(o=n),o!==t&&(this._swap(t,o),this._heapify_down(o))}pop(){const t=this._container;if(0===t.length)return null;if(1===t.length)return t.pop();this._swap(0,t.length-1);const e=t.pop();return this._heapify_down(),e}get first(){return this._container.length>0?this._container[0]:null}*iterate(){for(let t=0,e=this._container.length;t<e;++t)yield this._container[t].element}toArray(){return this.data().sort(((t,e)=>this._comparator(t,e)?-1:0))}data(){return this._container.map((t=>t.element))}raw_data(){return this._container}get length(){return this._container.length}get empty(){return 0===this.length}}class d{constructor(e=null,r=t){return this._Node=class{constructor(t,e=null,r=null,s=null){this.pivot=t,this.child1=e,this.child2=r,this.radius=s}},this._Leaf=class{constructor(t){this.points=t}},this._metric=r,e&&this.add(e),this}add(t){return t=t.map(((t,e)=>({index:e,element:t}))),this._root=this._construct(t),this}_construct(t){if(1===t.length)return new this._Leaf(t);{let e,r=this._greatest_spread(t),s=t.sort(((t,e)=>t.element[r]-e.element[r])),i=s.length,n=Math.floor(i/2),o=t[n],a=s.slice(0,n),h=s.slice(n,i),l=Math.max(...t.map((t=>this._metric(o.element,t.element))));return e=a.length>0&&h.length>0?new this._Node(o,this._construct(a),this._construct(h),l):new this._Leaf(t),e}}_greatest_spread(t){let e=t[0].element.length,r=new Array(e);for(let t=0;t<e;++t)r[t]=[1/0,-1/0];let s=t.reduce(((t,r)=>{for(let s=0;s<e;++s)t[s][0]=Math.min(t[s][0],r.element[s]),t[s][1]=Math.max(t[s][1],r.element[s]);return t}),r);s=s.map((t=>t[1]-t[0]));let i=0;for(let t=0;t<e;++t)i=s[t]>s[i]?t:i;return i}search(t,e=5){return this._search(t,e,new p(null,(e=>this._metric(e.element,t)),"max"),this._root)}_search(t,e,r,s){if(r.length>=e&&s.pivot&&s.radius&&this._metric(t,s.pivot.element)-s.radius>=r.first.value)return r;if(s.child1&&this._search(t,e,r,s.child1),s.child2&&this._search(t,e,r,s.child2),s.points)for(let t=0,i=s.points.length;t<i;++t){let i=s.points[t];e>r.length?r.push(i):(r.push(i),r.pop())}return r}}function m(e){const[s,i]=e.shape,n=new u(s,i,"identity"),o=new u(i,i,0);for(let a=0;a<i;++a){let i=e.col(a);for(let t=0;t<a;++t){const e=n.col(t),s=r(e.map(((t,e)=>t*i[e])));o.set_entry(t,a,s),i=i.map(((t,r)=>t-s*e[r]))}const h=c(i,t);for(let t=0;t<s;++t)n.set_entry(t,a,i[t]/h);o.set_entry(a,a,h)}return{R:o,Q:n}}function y(t,e=2,s=100,i=1212){let n;n=i instanceof f?i:new f(i),t instanceof u||(t=u.from(t));let o=t.shape[0],{Q:a,R:h}=m(new u(o,e,(()=>n.random)));for(;s--;){let e=h.clone(),i=m(t.dot(a));[a,h]=[i.Q,i.R],r(h.sub(e).diag)/o<1e-12&&(s=0)}return{eigenvalues:h.diag,eigenvectors:a.transpose().to2dArray}}class w{static parameter_list=[];constructor(e,r=2,s=t,i=1212){if(Array.isArray(e))this._type="array",this.X=u.from(e);else{if(!(e instanceof u))throw"no valid type for X";this._type="matrix",this.X=e}return[this._N,this._D]=this.X.shape,this._d=r,this._metric=s,this._seed=i,this._randomizer=new f(i),this._is_initialized=!1,this}parameter(t,e=null){if(-1===this.parameter_list.findIndex((e=>e===t)))throw t+" is not a valid parameter!";return e?(this["_"+t]=e,this):this["_"+t]}para(t,e=null){return this.parameter(t,e)}p(t,e=null){return this.parameter(t,e)}transform(){return this.check_init(),this.Y}check_init(){this._is_initialized||"function"!=typeof this.init||(this.init(),this._is_initialized=!0)}get projection(){return"matrix"===this._type?this.Y:this.Y.to2dArray}async transform_async(){return this.transform()}static transform(...t){return new this(...t).transform()}static async transform_async(...t){return this.transform(...t)}}class g extends w{constructor(t,e=2){return super(t,e),this}transform(){let t=this.X,e=t.shape[1],r=new u(e,e,"center"),s=t.dot(r),i=s.transpose().dot(s),{eigenvectors:n}=y(i,this._d);return n=u.from(n).transpose(),this.Y=t.dot(n),this.projection}}class A extends w{constructor(e,r=2,s=t,i=1212){return super(e,r,s,i),this}transform(){const t=this.X,e=t.shape[0],r=this._metric;let s=[],i=[];for(let t=0;t<e;++t)s.push(0),i.push(0);let n=0;const o=new u;o.shape=[e,e,(e,a)=>{let h=0;return e<a?h=r(t.row(e),t.row(a)):e>a&&(h=o.entry(a,e)),s[e]+=h,i[a]+=h,n+=h,h}],this._d_X=o,s=s.map((t=>t/e)),i=i.map((t=>t/e)),n/=e**2;const a=new u(e,e,((t,e)=>o.entry(t,e)-s[t]-i[e]+n)),{eigenvectors:h}=y(a,this._d);return this.Y=u.from(h).transpose(),this.projection}get stress(){const e=this.X.shape[0],r=this.Y,s=this._d_X,i=new u;i.shape=[e,e,(e,s)=>e<s?t(r.row(e),r.row(s)):i.entry(s,e)];let n=0,o=0;for(let t=0;t<e;++t)for(let r=t+1;r<e;++r)n+=Math.pow(s.entry(t,r)-i.entry(t,r),2),o+=Math.pow(s.entry(t,r),2);return Math.sqrt(n/o)}}class x extends w{static parameter_list=["k"];constructor(e,r,s=2,i=t,n=1212){return super(e,s,i,n),super.parameter_list=x.parameter_list,this.parameter("k",r??Math.max(Math.floor(this.X.shape[0]/10),2)),this}transform(){let t=this.X,e=t.shape[0],r=new u;r.shape=[e,e,(e,s)=>e<=s?this._metric(t.row(e),t.row(s)):r.entry(s,e)];let s=[];for(let t=0;t<e;++t){let e=r.row(t).map(((t,e)=>({index:e,distance:t}))),i=new p(e,(t=>t.distance),"min");s.push(i.toArray().slice(1,this._k+1))}let i=new u(e,e,((t,e)=>{let r=s[t].find((t=>t.index===e));return r?r.distance:1/0}));for(let t=0;t<e;++t)for(let r=0;r<e;++r)for(let s=0;s<e;++s)i.set_entry(t,r,Math.min(i.entry(t,r),i.entry(t,s)+i.entry(s,r)));let n=[],o=[];for(let t=0;t<e;++t)n.push(0),o.push(0);let a=0,h=new u(e,e,((t,e)=>{let r=i.entry(t,e);return r=r===1/0?0:r,n[t]+=r,o[e]+=r,a+=r,r}));n=n.map((t=>t/e)),o=o.map((t=>t/e)),a/=e**2;let l=new u(e,e,((t,e)=>h.entry(t,e)-n[t]-o[e]+a)),{eigenvectors:_}=y(l,this._d);return this.Y=u.from(_).transpose(),this.projection}parameter(t,e=null){return super.parameter(t,e)}para(t,e=null){return this.parameter(t,e)}p(t,e=null){return this.parameter(t,e)}}class v extends w{constructor(e,r=2,s=t,i=1212){return super(e,r,s,i),this._col=-1,this}_choose_distant_objects(t){const e=this.X.shape[0];let r=this._randomizer.random_int%e-1,s=null,i=-1/0;for(let n=0;n<e;++n){const e=t(r,n);e>i&&(i=e,s=n)}i=-1/0;for(let n=0;n<e;++n){const e=t(s,n);e>i&&(i=e,r=n)}return[r,s,i]}transform(){const t=this.X,e=t.shape[0],r=this._d,s=this._metric,i=new u(e,r);let n=(e,r)=>s(t.row(e),t.row(r)),o=n;for(;this._col<r-1;){this._col+=1;let t=this._col;const[r,s,a]=this._choose_distant_objects(n);if(0===a)for(let r=0;r<e;++r)i.set_entry(r,t,0);else{for(let o=0;o<e;++o){const e=(n(r,o)**2+a**2-n(s,o)**2)/(2*a);i.set_entry(o,t,e)}n=(e,r)=>Math.sqrt(o(e,r)**2-(i.entry(e,t)-i.entry(r,t))**2)}}return this.Y=i,this.projection}}class b extends w{static parameter_list=["labels"];constructor(e,r,s=2,i=t,n=1212){return super(e,s,i,n),super.parameter_list=b.parameter_list,this.parameter("labels",r),this}transform(){let t=this.X,[e,r]=t.shape,s=this._labels,i={},n=0;s.forEach(((e,r)=>{e in i?(i[e].count++,i[e].rows.push(t.row(r))):i[e]={id:n++,count:1,rows:[t.row(r)]}}));let o=t.mean,a=new u(n,r);for(let t in i){let e=u.from(i[t].rows).meanCols;for(let s=0;s<r;++s)a.set_entry(i[t].id,s,e[s])}let h=new u(r,r);for(let t in i){let e=a.row(i[t].id),s=new u(r,1,(t=>e[t]-o)),n=i[t].count;h=h.add(s.dot(s.transpose()).mult(n))}let l=new u(r,r);for(let t in i){let e=a.row(i[t].id),s=new u(r,1,(t=>e[t])),n=i[t].rows;for(let e=0,o=i[t].count;e<o;++e){let t=new u(r,1,((t,r)=>n[e][t]-s.entry(t,0)));l=l.add(t.dot(t.transpose()))}}let{eigenvectors:_}=y(l.inverse().dot(h),this.d);return _=u.from(_).transpose(),this.Y=t.dot(_),this.projection}}class z extends w{static parameter_list=["k"];constructor(e,r,s=2,i=t,n=1212){return super(e,s,i,n),super.parameter_list=z.parameter_list,this.parameter("k",r??Math.max(Math.floor(this.X.shape[0]/10),2)),this}transform(){const t=this.X,e=this._d,[s,i]=t.shape,n=this._k,o=h(t.to2dArray,n,null,this._metric),a=new u(n,1,1),l=new u(s,s);for(let e=0;e<s;++e){const s=new u(n,i,((r,s)=>t.entry(o[e][r].j,s)-t.entry(e,s))),h=s.dot(s.transpose());if(n>i){const t=r(h.diag)/1e3;for(let e=0;e<n;++e)h.set_entry(e,e,h.entry(e,e)+t)}let _=u.solve(h,a);const c=r(_.col(0));_=_.divide(c);for(let t=0;t<n;++t)l.set_entry(e,o[e][t].j,_.entry(t,0))}const _=new u(s,s,"identity").sub(l),c=_.transpose().dot(_),{eigenvectors:f}=y(c.transpose().inverse(),e+1);return this.Y=u.from(f.slice(1,1+e)).transpose(),this.projection}}class k extends w{static parameter_list=["k"];constructor(e,r,s=2,i=t,n=1212){return super(e,s,i,n),super.parameter_list=k.parameter_list,this.parameter("k",r??Math.max(Math.floor(this.X.shape[0]/10),2)),this}transform(){const t=this.X,e=this._d,[r,s]=t.shape,i=this._k,n=h(t.to2dArray,i,null,this._metric),o=new u(s,s,"center"),a=new u(r,r,0);for(let s=0;s<r;++s){const r=[s,...n[s].map((t=>t.j))];let h=u.from(r.map((e=>t.row(e))));h=h.dot(o);const l=h.dot(h.transpose()),{eigenvectors:_}=y(l,e),c=u.from(_),f=c.transpose().dot(c).add(1/Math.sqrt(i+1));for(let t=0;t<i+1;++t)for(let e=0;e<i+1;++e)a.set_entry(r[t],r[e],a.entry(r[t],r[e])-(t===e?1:0)+f.entry(t,e))}const{eigenvectors:l}=y(a,e+1);return this.Y=u.from(l.slice(1)).transpose(),this.projection}}class N extends w{static parameter_list=["perplexity","epsilon"];constructor(e,r=50,s=10,i=2,n=t,o=1212){return super(e,i,n,o),super.parameter_list=N.parameter_list,[this._N,this._D]=this.X.shape,this.parameter("perplexity",Math.min(r,this._N-1)),this.parameter("epsilon",s),this._iter=0,this.Y=new u(this._N,this._d,(()=>this._randomizer.random)),this}init(t=null){const e=Math.log(this._perplexity),r=this._N,s=this._D,i=this._metric,n=this.X;let o;if(t)o=t;else{o=new u(r,r);for(let t=0;t<r;++t)for(let e=t+1;e<r;++e){const r=i(n.row(t),n.row(e));o.set_entry(t,e,r),o.set_entry(e,t,r)}}const a=new u(r,r,"zeros");this._ystep=new u(r,s,"zeros"),this._gains=new u(r,s,1);let h=new Array(r).fill(0);for(let t=0;t<r;++t){let s=-1/0,i=1/0,n=1,l=!1,_=0;for(;!l;){let a=0;for(let e=0;e<r;++e){let r=Math.exp(-o.entry(t,e)*n);t===e&&(r=0),h[e]=r,a+=r}let c=0;for(let t=0;t<r;++t){let e=0===a?0:h[t]/a;h[t]=e,e>1e-7&&(c-=e*Math.log(e))}c>e?(s=n,n=i===1/0?2*n:(n+i)/2):(i=n,n=s===-1/0?n/2:(n+s)/2),++_,Math.abs(c-e)<1e-4&&(l=!0),_>=50&&(l=!0)}for(let e=0;e<r;++e)a.set_entry(t,e,h[e])}const l=new u(r,r,"zeros"),_=2*r;for(let t=0;t<r;++t)for(let e=t;e<r;++e){const r=Math.max((a.entry(t,e)+a.entry(e,t))/_,1e-100);l.set_entry(t,e,r),l.set_entry(e,t,r)}return this._P=l,this}transform(t=500){this.check_init();for(let e=0;e<t;++e)this.next();return this.projection}*generator(){for(this.check_init();;)this.next(),yield this.projection}next(){const t=++this._iter,e=this._P,r=this._ystep,s=this._gains,i=this._N,n=this._epsilon,o=this._d;let a=this.Y;const h=t<100?4:1,l=new u(i,i,"zeros");let _=0;for(let t=0;t<i;++t)for(let e=t+1;e<i;++e){let r=0;for(let s=0;s<o;++s){const i=a.entry(t,s)-a.entry(e,s);r+=i*i}const s=1/(1+r);l.set_entry(t,e,s),l.set_entry(e,t,s),_+=2*s}const c=new u(i,i,0);for(let t=0;t<i;++t)for(let e=t+1;e<i;++e){const r=Math.max(l.entry(t,e)/_,1e-100);c.set_entry(t,e,r),c.set_entry(e,t,r)}const f=new u(i,o,"zeros");for(let t=0;t<i;++t)for(let r=0;r<i;++r){const s=4*(h*e.entry(t,r)-c.entry(t,r))*l.entry(t,r);for(let e=0;e<o;++e)f.set_entry(t,e,f.entry(t,e)+s*(a.entry(t,e)-a.entry(r,e)))}let p=new Float64Array(o);for(let e=0;e<i;++e)for(let i=0;i<o;++i){const o=f.entry(e,i),h=r.entry(e,i),l=s.entry(e,i);let _=Math.sign(o)===Math.sign(h)?.8*l:l+.2;_<.01&&(_=.01),s.set_entry(e,i,_);const c=(t<250?.5:.8)*h-n*_*o;r.set_entry(e,i,c),a.set_entry(e,i,a.entry(e,i)+c),p[i]+=a.entry(e,i)}for(let t=0;t<i;++t)for(let e=0;e<2;++e)a.set_entry(t,e,a.entry(t,e)-p[e]/i);return this.Y}}function j(t,e,r=300){const s=e.length;let i=.001,n=1e4,o=e.slice(),a=t(o),h=!1;for(;r-- >=0&&!h;){h=!0;for(let e=0;e<s;++e){o[e]+=1e-6;let r=t(o);o[e]-=1e-6;let s=(r-a)/1e-6;Math.abs(s)>.01&&(h=!1),o[e]-=i*s,a=t(o)}i*=n>=a?1.05:.4,n=a}return o}class X extends w{static parameter_list=["local_connectivity","min_dist"];constructor(e,r=1,s=1,i=2,n=t,o=1212){return super(e,i,n,o),super.parameter_list=X.parameter_list,[this._N,this._D]=this.X.shape,this.parameter("local_connectivity",r),this.parameter("min_dist",s),this._iter=0,this._n_neighbors=11,this._spread=1,this._set_op_mix_ratio=1,this._repulsion_strength=1,this._negative_sample_rate=5,this._n_epochs=350,this._initial_alpha=1,this.Y=new u(this._N,this._d,(()=>this._randomizer.random)),this}_find_ab_params(t,e){for(var s=_(0,3*t,300),i=_(0,3*t,300),n=0,o=s.length;n<o;++n)s[n]<e?i[n]=1:i[n]=Math.exp(-(s[n]-e)/t);var[a,h]=j((function(t){var e=_(1,300).map(((e,r)=>i[r]-function(t,e,r){return 1/(1+e*Math.pow(t,2*r))}(s[r],t[0],t[1])));return Math.sqrt(r(e.map((t=>t*t))))}),[1,1]);return[a,h]}_compute_membership_strengths(t,e,r){for(let s=0,i=t.length;s<i;++s)for(let i=0,n=t[s].length;i<n;++i){let n=t[s][i].value-r[s],o=1;n>0&&(o=Math.exp(-n/e[s])),t[s][i].value=o}return t}_smooth_knn_dist(t,e){const r=.001,s=this._local_connectivity,i=1*Math.log2(e),n=[],o=[],a=this.X;let h=[];for(let r=0,i=a.shape[0];r<i;++r){let i=a.row(r);h.push(t.search(i,Math.max(s,e)).raw_data().reverse())}for(let t=0,s=a.shape[0];t<s;++t){let s=h[t];n.push(s[0].value);let a=0,l=1/0,_=1;for(let r=0;r<64;++r){let r=0;for(let i=0;i<e;++i){let e=s[i].value-n[t];r+=e>0?Math.exp(-e/_):1}if(Math.abs(r-i)<1e-5)break;r>i?(l=_,_=(a+l)/2):(a=_,l===1/0?_*=2:_=(a+l)/2)}o[t]=_;const c=s.reduce(((t,e)=>t+e.value),0)/s.length;if(n[t]>0)o[t]<r*c&&(o[t]=r*c);else{const e=h.reduce(((t,e)=>t+e.reduce(((t,e)=>t+e.value),0)/e.length));o[t]>r*e&&(o[t]=r*e)}}return{distances:h,sigmas:o,rhos:n}}_fuzzy_simplicial_set(e,r){const s=new d(e.to2dArray,t);let{distances:i,sigmas:n,rhos:o}=this._smooth_knn_dist(s,r);i=this._compute_membership_strengths(i,n,o);let a=new u(e.shape[0],e.shape[0],"zeros");for(let t=0,s=e.shape[0];t<s;++t)for(let e=0;e<r;++e)a.set_entry(t,i[t][e].element.index,i[t][e].value);const h=a.T,l=a.mult(h);return a=a.add(h).sub(l).mult(this._set_op_mix_ratio).add(l.mult(1-this._set_op_mix_ratio)),a}_make_epochs_per_sample(t,e){const{data:r}=this._tocoo(t);let s=new Array(r.length).fill(-1);const i=Math.max(...r),n=r.map((t=>e*(t/i)));return s=s.map(((t,r)=>n[r]>0?Math.round(e/n[r]):t)),s}_tocoo(t){const e=[],r=[],s=[],[i,n]=t.shape;for(let o=0;o<i;++o)for(let i=0;i<n;++i){const n=t.entry(o,i);0!==n&&(e.push(o),r.push(i),s.push(n))}return{rows:e,cols:r,data:s}}init(){const[t,e]=this._find_ab_params(this._spread,this._min_dist);this._a=t,this._b=e,this._graph=this._fuzzy_simplicial_set(this.X,this._n_neighbors),this._epochs_per_sample=this._make_epochs_per_sample(this._graph,this._n_epochs),this._epochs_per_negative_sample=this._epochs_per_sample.map((t=>t*this._negative_sample_rate)),this._epoch_of_next_sample=this._epochs_per_sample.slice(),this._epoch_of_next_negative_sample=this._epochs_per_negative_sample.slice();const{rows:r,cols:s}=this._tocoo(this._graph);return this._head=r,this._tail=s,this}set local_connectivity(t){this._local_connectivity=t}get local_connectivity(){return this._local_connectivity}set min_dist(t){this._min_dist=t}get min_dist(){return this._min_dist}transform(t){this.check_init(),t=t||this._n_epochs;for(let e=0;e<t;++e)this.next();return this.projection}*generator(){for(this.check_init(),this._iter=0;this._iter<this._n_epochs;)this.next(),yield this.projection;return this.projection}_clip(t){return t>4?4:t<-4?-4:t}_optimize_layout(e,r,s,i){const{_d:n,_alpha:o,_repulsion_strength:a,_a:h,_b:l,_epochs_per_sample:_,_epochs_per_negative_sample:c,_epoch_of_next_negative_sample:u,_epoch_of_next_sample:f,_clip:p}=this,d=i.length;for(let m=0,y=_.length;m<y;++m)if(f[m]<=this._iter){const y=s[m],w=i[m],g=e.row(y),A=r.row(w),x=t(g,A);let M=0;x>0&&(M=-2*h*l*Math.pow(x,l-1)/(h*Math.pow(x,l)+1));for(let t=0;t<n;++t){const s=p(M*(g[t]-A[t]))*o,i=g[t]+s,n=A[t]-s;g[t]=i,A[t]=n,e.set_entry(y,t,i),r.set_entry(w,t,n)}f[m]+=_[m];const v=(this._iter-u[m])/c[m];for(let s=0;s<v;++s){const s=Math.floor(this._randomizer.random*d),_=r.row(i[s]),c=t(g,_);let u=0;if(c>0)u=2*a*l/((.01+c)*(h*Math.pow(c,l)+1));else if(y==s)continue;for(let t=0;t<n;++t){const n=p(u*(g[t]-_[t]))*o,a=g[t]+n,h=_[t]-n;g[t]=a,_[t]=h,e.set_entry(y,t,a),r.set_entry(i[s],t,h)}}u[m]+=v*c[m]}return e}next(){let t=++this._iter,e=this.Y;return this._alpha=this._initial_alpha*(1-t/this._n_epochs),this.Y=this._optimize_layout(e,e,this._head,this._tail),this.Y}}class Y extends w{static parameter_list=["weight_adj","c"];constructor(e,r=500,s=5,i=2,n=t,o=1212){return super(e,i,n,o),super.parameter_list=Y.parameter_list,this.parameter("weight_adj",r),this.parameter("c",s),this}init(t=null,e=null){const r=this.X,s=r.shape[0],i=this._d,n=this._metric,o=this._c;this.n_inliers=2*o,this.n_outliers=1*o,this.n_random=1*o,this.Y=t||new g(r,i).transform(),this.knn=e||new d(r.to2dArray,n);const{triplets:a,weights:h}=this._generate_triplets(this.n_inliers,this.n_outliers,this.n_random);return this.triplets=a,this.weights=h,this.lr=1e3*s/a.shape[0],this.C=1/0,this.tol=1e-7,this.vel=new u(s,i,0),this.gain=new u(s,i,1),this}_generate_triplets(t,e,r){const s=this._metric,i=this._weight_adj,n=this.X,o=n.shape[0],a=this.knn,h=Math.min(t+20,o),l=new u(o,h),_=new u(o,h);for(let t=0;t<o;++t)a.search(n.row(t),h+1).raw_data().filter((t=>0!=t.value)).sort(((t,e)=>t.value-e.value)).forEach(((e,r)=>{l.set_entry(t,r,e.element.index),_.set_entry(t,r,e.value)}));const c=new Float64Array(o);for(let t=0;t<o;++t)c[t]=Math.max((_.entry(t,3)+_.entry(t,4)+_.entry(t,5)+_.entry(t,6))/4,1e-10);const f=this._find_p(_,c,l);let p=this._sample_knn_triplets(f,l,t,e),d=p.shape[0];const m=new Float64Array(d);for(let t=0;t<d;++t){const e=p.entry(t,0),r=p.entry(t,2);m[t]=s(n.row(e),n.row(r))}let y=this._find_weights(p,f,l,m,c);if(r>0){const{random_triplets:t,random_weights:e}=this._sample_random_triplets(n,r,c);p=p.concat(t,"vertical"),y=Float64Array.from([...y,...e])}d=p.shape[0];let w=-1/0;for(let t=0;t<d;++t)isNaN(y[t])&&(y[t]=0),w<y[t]&&(w=y[t]);let g=-1/0;for(let t=0;t<d;++t)y[t]/=w,y[t]+=1e-4,y[t]=Math.log(1+i*y[t]),g<y[t]&&(g=y[t]);for(let t=0;t<d;++t)y[t]/=g;return{triplets:p,weights:y}}_find_p(t,e,r){const[s,i]=t.shape;return new u(s,i,((s,i)=>Math.exp(-(t.entry(s,i)**2)/e[s]/e[r.entry(s,i)])))}_sample_knn_triplets(t,e,r,s){const i=e.shape[0],n=new u(i*r*s,3);for(let o=0;o<i;++o){let a=o*r*s;const h=this.__argsort(t.row(o).map((t=>-t)));for(let t=0;t<r;++t){let r=t*s;const l=e.entry(o,h[t]),_=this._rejection_sample(s,i,h.slice(0,t+1));for(let t=0;t<s;++t){const e=a+r+t,s=_[t];n.set_entry(e,0,o),n.set_entry(e,1,l),n.set_entry(e,2,s)}}}return n}__argsort(t){return t.map(((t,e)=>({d:t,i:e}))).sort(((t,e)=>t.d-e.d)).map((t=>t.i))}_rejection_sample(t,e,r){const s=this._randomizer,i=_(0,e-1).filter((t=>r.indexOf(t)<0));return s.choice(i,Math.min(t,i.length-2))}_find_weights(t,e,r,s,i){const n=t.shape[0],o=new Float64Array(n);for(let a=0;a<n;++a){const n=t.entry(a,0),h=r.row(n).indexOf(t.entry(a,1)),l=e.entry(n,h);let _=Math.exp(-(s[a]**2)/(i[n]*i[t.entry(a,2)]));_<1e-20&&(_=1e-20),o[a]=l/_}return o}_sample_random_triplets(t,e,r){const s=this._metric,i=this._randomizer,n=t.shape[0],o=new u(n*e,3),a=new Float64Array(n*e);for(let h=0;h<n;++h){const l=h*e,c=[..._(0,h-1),..._(h+1,n-1)];for(let n=0;n<e;++n){let[e,_]=i.choice(c,2),u=Math.exp(-(s(t.row(h),t.row(e))**2)/(r[h]*r[e]));u<1e-20&&(u=1e-20);let f=Math.exp(-(s(t.row(h),t.row(_))**2)/(r[h]*r[_]));f<1e-20&&(f=1e-20),u<f&&([e,_]=[_,e],[u,f]=[f,u]);const p=l+n;o.set_entry(p,0,h),o.set_entry(p,1,e),o.set_entry(p,2,_),a[p]=u/f}}return{random_triplets:o,random_weights:a}}_grad(t){const e=this.n_inliers,r=this.n_outliers,s=this.triplets,i=this.weights,[n,o]=t.shape,a=s.shape[0],h=new u(n,o,0);let l=new Array(o).fill(0),_=new Array(o).fill(0),c=1,f=1,p=0,d=0;const m=n*e*r;for(let e=0;e<a;++e){const[n,a,u]=s.row(e);if(e%r==0||e>=m){c=1,f=1;for(let e=0;e<o;++e){const r=t.entry(n,e),s=t.entry(a,e),i=t.entry(u,e);l[e]=r-s,_[e]=r-i,c+=l[e]**2,f+=_[e]**2}}else{f=1;for(let e=0;e<o;++e){const r=t.entry(n,e),s=t.entry(u,e);_[e]=r-s,f+=_[e]**2}}c>f&&++p,d+=i[e]/(1+f/c);const y=(i[e]/(c+f))**2;for(let t=0;t<o;++t){const e=l[t]*f*y,r=_[t]*c*y;h.set_entry(n,t,h.entry(n,t)+e-r),h.set_entry(a,t,h.entry(a,t)-e),h.set_entry(u,t,h.entry(u,t)+r)}}return{grad:h,loss:d,n_viol:p}}transform(t=400){this.check_init();for(let e=0;e<t;++e)this._next(e);return this.projection}*generator(){this.check_init();for(let t=0;t<800;++t)this._next(t),yield this.projection;return this.projection}_next(t){const e=t>150?.5:.3,r=this.C,s=this.vel,i=this.Y.add(s.mult(e)),{grad:n,loss:o,n_viol:a}=this._grad(i);return this.C=o,this.Y=this._update_embedding(i,t,n),this.lr*=r>o+this.tol?1.01:.9,this.Y}_update_embedding(t,e,r){const[s,i]=t.shape,n=e>150?.9:.5,o=this.gain,a=this.vel,h=this.lr;for(let e=0;e<s;++e)for(let s=0;s<i;++s){const i=Math.sign(a.entry(e,s))!=Math.sign(r.entry(e,s))?o.entry(e,s)+.2:Math.max(.8*o.entry(e,s),.01);o.set_entry(e,s,i),a.set_entry(e,s,n*a.entry(e,s)-h*o.entry(e,s)*r.entry(e,s)),t.set_entry(e,s,t.entry(e,s)+a.entry(e,s))}return t}}class F{constructor(e,r="single",s=t){return this._id=0,this._matrix=e,this._metric=s,this._linkage=r,this.init(),this.root=this.do(),this}get_clusters(t,e="distance"){let r,s=[];switch(e){case"distance":r=t=>t.dist;break;case"depth":r=t=>t.depth;break;default:throw"invalid type"}return this._traverse(this.root,r,t,s),s}_traverse(t,e,r,s){e(t)<=r?s.push(t.leaves()):(this._traverse(t.left,e,r,s),this._traverse(t.right,e,r,s))}init(){const t=this._metric,e=this._matrix,r=this._n=e.shape[0],s=this._d_min=new Float64Array(r),i=this._distance_matrix=new Array(r);for(let n=0;n<r;++n){s[n]=0,i[n]=new Float64Array(r);for(let o=0;o<r;++o)i[n][o]=n===o?1/0:t(e.row(n),e.row(o)),i[n][s[n]]>i[n][o]&&(s[n]=o)}const n=this._clusters=new Array(r),o=this._c_size=new Uint16Array(r);for(let t=0;t<r;++t)n[t]=[],n[t][0]=new E(this._id++,null,null,0,e.row(t),t,1,0),o[t]=1;return this}do(){const t=this._n,e=this._d_min,r=this._distance_matrix,s=this._clusters,i=this._c_size,n=this._linkage;let o=null;for(let a=0,h=t-1;a<h;++a){let a=0;for(let s=0;s<t;++s)r[s][e[s]]<r[a][e[a]]&&(a=s);let h=e[a],l=s[a][0],_=s[h][0],c=new E(this._id++,l,_,r[a][h]);s[a].unshift(c),i[a]+=i[h];for(let e=0;e<t;++e)switch(n){case"single":r[a][e]>r[h][e]&&(r[e][a]=r[a][e]=r[h][e]);break;case"complete":r[a][e]<r[h][e]&&(r[e][a]=r[a][e]=r[h][e]);break;case"average":r[e][a]=r[a][e]=(i[a]*r[a][e]+i[h]*r[h][e])/(i[a]+i[e])}r[a][a]=1/0;for(let e=0;e<t;++e)r[e][h]=r[h][e]=1/0;for(let s=0;s<t;++s)e[s]===h&&(e[s]=a),r[a][s]<r[a][e[a]]&&(e[a]=s);o=c}return o}}class E{constructor(t,e,r,s,i,n,o,a){return this.id=t,this.left=e,this.right=r,this.dist=s,this.index=n,this.size=null!=o?o:e.size+r.size,this.depth=null!=a?a:1+Math.max(e.depth,r.depth),this.centroid=null!=i?i:this._calculate_centroid(e,r),this}_calculate_centroid(t,e){const r=t.size,s=e.size,i=t.centroid,n=e.centroid,o=this.size,a=t.centroid.length,h=new Float64Array(a);for(let t=0;t<a;++t)h[t]=(r*i[t]+s*n[t])/o;return h}get isLeaf(){return 0===this.depth}leaves(){if(this.isLeaf)return[this.index];const t=this.left,e=this.right;return(t.isLeaf?[t.index]:t.leaves()).concat(e.isLeaf?[e.index]:e.leaves())}}class L{constructor(e,r,s=t,i=1987,n=!0){this._metric=s,this._matrix=e,this._K=r;const[o,a]=e.shape;return this._N=o,this._D=a,r>o&&(r=o),this._randomizer=new f(i),this._clusters=new Array(o).fill(void 0),this._cluster_centroids=this._get_random_centroids(r),n&&this.init(r,this._cluster_centroids),this}get_clusters(){const t=this._K,e=this._clusters,r=new Array(t).fill().map((()=>new Array));return e.forEach(((t,e)=>r[t].push(e))),r}_furthest_point(t,e){const r=this._matrix,s=this._metric;let i=t.length;return p.heapify(e,(e=>{const n=r.row(e);let o=0;for(let e=0;e<i;++e)o+=s(n,t[e]);return o}),"max").pop().element}_get_random_centroids(t){const e=this._N,r=this._randomizer,s=this._matrix,i=new Array(t).fill(),n=_(0,e-1),o=r.random_int%(e-1);i[0]=s.row(o);const a=[o],h=Math.floor((e-t)/t);for(let e=1;e<t;++e){const t=r.choice(n.filter((t=>-1==a.indexOf(t))),h),o=this._furthest_point(i.slice(0,e),t);a.push(o),i[e]=s.row(o)}return i}_iteration(t){const e=t.length,r=this._N,s=this._D,i=this._matrix,n=this._metric,o=this._clusters;let a=!1;for(let s=0;s<r;++s){const r=i.row(s);let h=1/0,l=null;for(let s=0;s<e;++s){let e=n(t[s],r);e<h&&(h=e,l=s)}o[s]!==l&&(a=!0),o[s]=l}for(let r=0;r<e;++r){const e=t[r];for(let t=0;t<s;++t)e[t]=0}return this._compute_centroid(t),{clusters_changed:a,cluster_centroids:t}}_compute_centroid(t){const e=t.length,r=this._N,s=this._D,i=this._matrix,n=this._clusters,o=new Array(e).fill(0);for(let e=0;e<r;++e){const r=i.row(e),a=n[e];o[a]++;const h=t[a];for(let t=0;t<s;++t)h[t]+=r[t]}for(let r=0;r<e;++r){const e=o[r];t[r]=t[r].map((t=>t/e))}}init(t,e){t||(t=this._K),e||(e=this._get_random_centroids(t));let r=!1;do{const t=this._iteration(e);e=t.cluster_centroids,r=t.clusters_changed}while(r)}}class B{constructor(e,r,s=null,i=t,n=1212){this._metric=i,this._matrix=e,this._A=this._matrix.to2dArray,this._K=r;const[o,a]=e.shape;return this._N=o,this._D=a,this._max_iter=s||10*Math.log10(o),this._distance_matrix=new u(o,o,"zeros"),r>o&&(r=o),this._randomizer=new f(n),this._clusters=new Array(o).fill(void 0),this._cluster_medoids=this._get_random_medoids(r),this._is_initialized=!1,this}get_clusters(){const t=this._K,e=this._A;this._is_initialized||this.init(t,this._cluster_medoids);const r=new Array(t).fill().map((()=>new Array));return e.forEach(((t,e)=>{r[this._nearest_medoid(t,e).index_nearest].push(e)})),r.medoids=this._cluster_medoids,r}async*generator(){const t=this._max_iter;yield this.get_clusters();let e=!1,r=0;do{e=this._iteration(),yield this.get_clusters()}while(!e&&++r<t)}_iteration(){const t=this._A,e=this._K,r=this._cluster_medoids,s=t.map(((t,e)=>this._nearest_medoid(t,e))),i=new Array(e).fill(0),n=new Array(e).fill(null);if(t.forEach(((o,a)=>{if(r.findIndex((t=>t===a))<0){const r=s[a].distance_nearest,h=new Array(e).fill(-r);t.forEach(((t,r)=>{if(a===r)return;const i=this._get_distance(r,a,t,o),{index_nearest:n,distance_nearest:l,distance_second:_}=s[r];if(h[n]+=Math.min(i,_)-l,i<l)for(let t=0;t<e;++t)t!==n&&(h[t]+=i-l)})),h.map(((t,e)=>[t,e])).filter((([t,e])=>t<i[e])).forEach((([t,e])=>{t<i[e]&&(i[e]=t,n[e]=a)}))}})),Math.min(...i)>=0)return!0;for(;Math.min(...i)<0;){const e=i.map(((t,e)=>[t,e])).sort((([t],[e])=>t-e))[0][1];0==r.filter((t=>t==n[e])).length&&(r[e]=n[e]),i[e]=0,i.map(((t,e)=>[t,e])).filter((([t])=>t<0)).forEach((([n,o])=>{const a=t[o];let h=0;t.forEach(((t,i)=>{r.findIndex((t=>t!=o&&t==i))>=0||e!=o&&(s[i].index_nearest===r[o]?h+=Math.min(this._get_distance(i,o,t,a),s[i].distance_second)-s[i].distance_nearest:h+=Math.min(this._get_distance(i,o,t,a)-s[i].distance_nearest,0))})),i[o]=h}))}return this._cluster_medoids=r,!1}_get_distance(t,e,r=null,s=null){if(t===e)return 0;const i=this._distance_matrix,n=this._A,o=this._metric;let a=i.entry(t,e);return 0===a&&(a=o(r||n[t],s||n[e]),i.set_entry(t,e,a),i.set_entry(e,t,a)),a}_nearest_medoid(t,e){const r=this._cluster_medoids,s=this._A,[i,n]=r.map(((r,i)=>{const n=s[r];return[this._get_distance(e,r,t,n),i]})).sort(((t,e)=>t[0]-e[0]));return{distance_nearest:i[0],index_nearest:i[1],distance_second:n[0],index_second:n[1]}}init(t,e){t||(t=this._K),e||(e=this._get_random_medoids(t));const r=this._max_iter;let s=!1,i=0;do{s=this._iteration()}while(!s&&++i<r);return this}_get_random_medoids(t){const e=this._N,r=this._A,s=_(0,e-1),i=this._randomizer,n=Math.min(e,10+Math.ceil(Math.sqrt(e))),o=new Array(n).fill(1/0),a=[];let h=1/0,l=i.choice(s,n);for(let t=0;t<n;++t){const e=l[t],s=r[e];for(let e=0;e<n;++e){if(e===t)continue;const i=r[l[e]];o[t]+=this._get_distance(t,e,s,i)}o[t]<h&&(h=o[t],a.push(e))}for(let e=1;e<t;++e){let t=1/0;l=i.choice(s.filter((t=>a.findIndex((e=>e===t))<0)),n);for(let e=0;e<n;++e){let s=0;const i=l[e],o=r[i];for(let t=0;t<n;++t){if(t===e)continue;const n=l[t],h=r[n];let _=this._get_distance(i,n,o,h)-Math.min(...a.map((t=>this._get_distance(n,t,h))));_<0&&(s+=_)}s<t&&(t=s,a.push(i))}h+=t}return a.slice(0,t)}}class K{constructor(e,r,s,i=t){return this._matrix=e,this._epsilon=r,this._min_points=s,this._metric=i,this._ordered_list=[],this._clusters=[],this._DB=new Array(e.shape[0]).fill(),this.init(),this}init(){const t=this._ordered_list,e=this._matrix,r=e.shape[0],s=this._DB,i=this._clusters;let n=this._cluster_index=0;for(let t=0;t<r;++t)s[t]={element:e.row(t),index:t,reachability_distance:void 0,processed:!1};for(const e of s)if(!e.processed&&(e.neighbors=this._get_neighbors(e),e.processed=!0,i.push([e.index]),n=i.length-1,t.push(e),null!=this._core_distance(e))){const t=new p(null,(t=>t.reachability_distance),"min");this._update(e,t),this._expand_cluster(t,i[n])}return this}_get_neighbors(t){if("neighbors"in t)return t.neighbors;const e=this._DB,r=this._metric,s=this._epsilon,i=[];for(const n of e)n.index!=t.index&&r(t.element,n.element)<s&&i.push(n);return i}_core_distance(t){const e=this._min_points,r=this._metric;if(!(t.neighbors&&t.neighbors.length<=e))return r(t.element,t.neighbors[e].element)}_update(t,e){const r=this._metric,s=this._core_distance(t),i=this._get_neighbors(t);for(const n of i){if(n.processed)continue;const i=Math.max(s,r(t.element,n.element));e.raw_data().findIndex((t=>t.element==n))<0?(n.reachability_distance=i,e.push(n)):i<n.reachability_distance&&(n.reachability_distance=i,e=p.heapify(e.data(),(t=>t.reachability_distance),"min"))}}_expand_cluster(t,e){const r=this._ordered_list;for(;!t.empty;){const s=t.pop().element;s.neighbors=this._get_neighbors(s),s.processed=!0,e.push(s.index),r.push(s),null!=this._core_distance(s)&&(this._update(s,t),this._expand_cluster(t,e))}}get_clusters(){const t=[],e=[],r=this._min_points;for(const s of this._clusters)s.length<r?e.push(...s):t.push(s);return t.push(e),t}get_cluster_affirmation(){const t=this._matrix.shape[0],e=new Array(t).fill(),r=this.get_clusters();for(let t=0,s=r.length;t<s;++t){const i=r[t];for(const r of i)e[r]=t<s-1?t:-1}return e}}class $ extends w{static parameter_list=["k","control_points"];constructor(e,r,s,i=2,n=t,o=1212){return super(e,i,n,o),super.parameter_list=$.parameter_list,this.parameter("k",r||Math.max(Math.floor(this.X.shape[0]/10),2)),this.parameter("control_points",s||Math.ceil(Math.sqrt(this._N))),this._is_initialized=!1,this}init(t=A,e=d){if(this._is_initialized)return;const r=this.X,s=this._N,i=this.parameter("k"),n=this._d,o=this._metric,a=this.parameter("control_points"),h=new B(r,a,null,o).get_clusters().medoids,l=new u(a,s,"zeros");h.forEach(((t,e)=>{l.set_entry(e,t,1)}));const _=new t(u.from(h.map((t=>r.row(t))))).transform(),c=r.to2dArray,f=new e(c,o),p=new u(s,s,"I"),m=-1/i;c.forEach(((t,e)=>{for(const{index:r}of f.search(t,i).iterate())e!==r&&p.set_entry(e,r,m)}));const y=p.concat(l,"vertical"),w=new u(s,n,"zeros").concat(_,"vertical");return this._A=y,this._b=w,this._is_initialized=!0,this}transform(){this._is_initialized||this.init();const t=this._A,e=t.T,r=this._b,s=e.dot(t),i=e.dot(r);return this.Y=u.solve_CG(s,i,this._randomizer),this.projection}}var R="0.3.1";export{d as BallTree,v as FASTMAP,p as Heap,F as Hierarchical_Clustering,x as ISOMAP,L as KMeans,B as KMedoids,b as LDA,z as LLE,$ as LSP,k as LTSA,A as MDS,u as Matrix,K as OPTICS,g as PCA,f as Randomizer,N as TSNE,Y as TriMap,X as UMAP,a as canberra,o as chebyshev,i as cosine,l as distance_matrix,t as euclidean,s as euclidean_squared,h as k_nearest_neighbors,e as kahan_sum,_ as linspace,n as manhattan,r as neumair_sum,c as norm,j as powell,m as qr,y as simultaneous_poweriteration,R as version};
