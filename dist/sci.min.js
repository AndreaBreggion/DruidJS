// https://null.org v0.0.1 Copyright 2019 abc
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t=t||self).sci=t.sci||{})}(this,function(t){"use strict";function e(t,e,r){if(!(t<0||e<0)){if(0===t&&0===e)return r(0,0);if(0===e){let e=new Array(t);for(let s=0;s<t;++s)e[s]=r(s);return e}{let s=new Array(t);for(let i=0;i<t;++i){s[i]=new Array(e);for(let t=0;t<e;++t)s[i][t]=r(i,t)}return s}}}function s(t=0,r=0){return e(t,r,()=>0)}function i(t){let e=t.length,r=0,s=0;for(let i=0;i<e;++i){let e=t[i],n=r+e;Math.abs(r)>=Math.abs(e)?s+=r-n+e:s+=e-n+r,r=n}return r+s}function n(t,e){if(t.length!=e.length)return;let r=t.length,s=new Array(r);for(let i=0;i<r;++i)s[i]=(t[i]-e[i])*(t[i]-e[i]);return Math.sqrt(i(s))}const o=n;function h(t,e=o){let r=e;if(void 0===r)return;let i=t.length,n=s(i,i);for(let e=0;e<i;++e)for(let s=e+1;s<i;++s)n[e][s]=n[s][e]=r(t[e],t[s]);return n}const a=n;function _(t,e,r=null,s=a){let i=t.length,n=r||h(t,s);for(let t=0;t<i;++t)n[t]=n[t].map((e,r)=>({i:t,j:r,distance:n[t][r]})).sort((t,e)=>t.distance-e.distance).slice(1,e+1);return n}function f(t,r){return e(t,r,()=>Math.random())}function c(t,e){let r=t.length,i=Array.isArray(t[0])?t[0].length:0,n=e.length,l=Array.isArray(e[0])?e[0].length:0,o=null;if(i&&l){if(i!==n)return;o=s(r,n);for(let s=0;s<r;++s)for(let r=0;r<l;++r)for(let n=0;n<i;++n)o[s][r]+=t[s][n]*e[n][r]}else if(i&&0==l){o=s(r,0);for(let s=0;s<r;++s)for(let r=0;r<i;++r)o[r]+=t[s][r]*e[r]}else if(0==i&&l){o=s(r,0);for(let s=0;s<r;++s)for(let r=0;r<n;++r)o[r]=t[s]*e[r][s]}else{if(0!=i||0!=l)return;if(r!==n)return;o=0;for(let s=0;s<r;++s)o+=t[s]*e[s]}return o}function y(t,e){if(!Array.isArray(t))return t*e;let r,s=t.length;if(Array.isArray(t[0])){let i=t[0].length;r=[];for(let n=0;n<s;++n){let s=[];for(let r=0;r<i;++r)s[r]=t[n][r]*e;r.push(s)}}else{r=[];for(let i=0;i<s;++i)r.push(t[i]*e)}return r}function d(t,e){return y(t,1/e)}function p(t,e=n){return e(t,s(t.length,0))}function m(t){let e,r=t.length;if(Array.isArray(t[0])){let s=t[0].length;e=new Array(s);for(let i=0;i<s;++i){let s=new Array(r);for(let e=0;e<r;++e)s[e]=t[e][i];e[i]=s}}else{e=new Array(r);for(let s=0;s<r;++s)e[s]=[t[s]]}return e}function w(t,e){let r,s=t.length,i=Array.isArray(t),n=Array.isArray(e);if(i&&n){if(s!==e.length)return;r=new Array(s);for(let i=0;i<s;++i)r[i]=t[i]+e[i];return r}if(Array.isArray(t[0])){let i=t[0].length;r=new Array(s);for(let n=0;n<s;++n){r[n]=new Array(i);for(let s=0;s<i;++s)r[n][s]=t[n][s]+e}}else{r=new Array(s);for(let i=0;i<s;++i)r[i]=t[i]+e}return r}function g(t){let[e,r]=t.shape,s=new x(e,r,"identity"),l=new x(r,r,0);for(let o=0;o<r;++o){let r=t.col(o);for(let t=0;t<o;++t){let e=s.col(t),n=i(e.map((t,e)=>t*r[e]));l.set_entry(t,o,n),r=r.map((t,r)=>t-n*e[r])}let h=p(r,n);for(let t=0;t<e;++t)s.set_entry(t,o,r[t]/h);l.set_entry(o,o,h)}return{R:l,Q:s}}class A{constructor(t){return this._N=624,this._M=397,this._MATRIX_A=2567483615,this._UPPER_MASK=2147483648,this._LOWER_MASK=2147483647,this._mt=new Array(this._N),this._mti=this.N+1,this.seed=t||(new Date).getTime(),this}set seed(t){this._seed=t;let e=this._mt;for(e[0]=t>>>0,this._mti=1;this._mti<this._N;this._mti+=1){let t=this._mti,r=e[t-1]^e[t-1]>>>30;e[t]=(1812433253*((4294901760&r)>>>16)<<16)+1812433253*(65535&r)+t,e[t]>>>=0}}get seed(){return this._seed}get random(){return this.random_int*(1/4294967296)}get random_int(){let t,e=new Array(0,this._MATRIX_A);if(this._mti>=this._N){let r;this._mti==this._N+1&&(this.seed=5489);let s=this._N-this._M,i=this._M-this._N;for(r=0;r<s;++r)t=this._mt[r]&this._UPPER_MASK|this._mt[r+1]&this._LOWER_MASK,this._mt[r]=this._mt[r+this._M]^t>>>1^e[1&t];for(;r<this._N-1;++r)t=this._mt[r]&this._UPPER_MASK|this._mt[r+1]&this._LOWER_MASK,this._mt[r]=this._mt[r+i]^t>>>1^e[1&t];t=this._mt[this._N-1]&this._UPPER_MASK|this._mt[0]&this._LOWER_MASK,this._mt[this._N-1]=this._mt[this._M-1]^t>>>1^e[1&t],this._mti=0}return t=this._mt[this._mti+=1],t^=t>>>11,t^=t<<7&2636928640,t^=t<<15&4022730752,(t^=t>>>18)>>>0}}function M(t,e=2,r=100,s=19870307){let n=new A(s);t instanceof x||(t=x.from(t));let l=t.shape[0],{Q:o,R:h}=g(new x(l,e,()=>n.random));for(;r--;){let e=h.clone(),s=g(t.dot(o));[o,h]=[s.Q,s.R],i(h.sub(e).diag)/l<1e-12&&(r=0)}return{eigenvalues:h.diag,eigenvectors:o.transpose().to2dArray}}class x{constructor(t=null,e=null,r=null){if(this._rows=t,this._cols=e,this._data=null,t&&e){if(!r)return this._data=new Float64Array(t*e),this;if("function"==typeof r){this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r(s,t);return this}if("string"==typeof r){if("zeros"===r)return new x(t,e,0);if("identity"===r||"I"===r){this._data=new Float64Array(t*e);for(let r=0;r<t;++r)this._data[r*e+r]=1;return this}if("center"===r&&t==e){this._data=new Float64Array(t*e),r=((e,r)=>(e===r?1:0)-1/t);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r(s,t);return this}}if("number"==typeof r){this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r;return this}}return this}static from(t,e){if(t instanceof x)return t.clone();if(!Array.isArray(t)){if("number"==typeof t)return new x(1,1,t);throw"error"}{let r=t.length;if(0===r)return B;if(!Array.isArray(t[0])){if("row"===e||null===e)return new x(1,r,(e,r)=>t[r]);if("col"===e)return new x(r,1,(e,r)=>t[e]);throw"1d array has NaN entries"}if(Array.isArray(t[0])){let e=t[0].length;for(let s=0;s<r;++s)if(t[s].length!==e)throw"various array lengths";return new x(r,e,(e,r)=>t[e][r])}}}row(t){let e=new Array(this._cols);for(let r=0;r<this._cols;++r)e[r]=this._data[t*this._cols+r];return e}set_row(t,e){let r=this._cols;if(Array.isArray(e)&&e.length===r){let s=t*r;for(let t=0;t<r;++t)this._data[s+t]=e[t]}else if(e instanceof x&&e.shape[1]===r&&1===e.shape[0]){let s=t*r;for(let t=0;t<r;++t)this._data[s+t]=e._data[t]}return this}col(t){let e=new Array(this._rows);for(let r=0;r<this._rows;++r)e[r]=this._data[r*this._cols+t];return e}entry(t,e){return this._data[t*this._cols+e]}set_entry(t,e,r){this._data[t*this._cols+e]=r}transpose(){return new x(this._cols,this._rows,(t,e)=>this.entry(e,t))}get T(){return this.transpose()}inverse(){const t=this._rows,e=this._cols;let r=new x(t,2*e,(t,r)=>r>=e?t===r-e?1:0:this.entry(t,r)),s=0,i=0;for(;s<t&&i<e;){var n=0;let l=-1/0;for(let e=s;e<t;++e){let t=Math.abs(r.entry(e,i));l<t&&(n=e,l=t)}if(0==r.entry(n,i))i++;else{for(let t=0;t<2*e;++t){let e=r.entry(s,t),i=r.entry(n,t);r.set_entry(s,t,e),r.set_entry(n,t,i)}for(let n=s+1;n<t;++n){let t=r.entry(n,i)/r.entry(s,i);r.set_entry(n,i,0);for(let l=i+1;l<2*e;++l)r.set_entry(n,l,r.entry(n,l)-r.entry(s,l)*t)}s++,i++}}for(let s=0;s<t;++s){let t=r.entry(s,s);for(let i=s;i<2*e;++i)r.set_entry(s,i,r.entry(s,i)/t)}for(let s=t-1;s>=0;--s){let t=r.entry(s,s);for(let i=0;i<s;i++){let n=r.entry(i,s)/t;for(let t=i;t<2*e;++t){let e=r.entry(i,t);e-=r.entry(s,t)*n,r.set_entry(i,t,e)}}}return new x(t,e,(t,s)=>r.entry(t,s+e))}dot(t){if(t instanceof x){let e=this;if(e.shape[1]!==t.shape[0])return;let r=e.shape[1];return new x(e.shape[0],t.shape[1],(s,n)=>{let l=e.row(s),o=t.col(n);for(let t=0;t<r;++t)l[t]=l[t]*o[t];return i(l)})}if(Array.isArray(t)){let e=this._rows;if(t.length!==e)return;let r=new Array(e);for(let s=0;s<e;++s)r[s]=i(this.row(s).map(e=>e*t[s]));return r}}outer(t){let e=this,r=e._data.length;if(r!=t._data.length)return;let s=new x;return s.shape=[r,r,(r,i)=>r<=i?e._data[r]*t._data[i]:s.entry(i,r)],s}householder(t){let e=this.col(t).slice(t),r=e[0],s=p(e),i=-(r<0?-1:1)*s;e[0]-=i,e=x.from(e,"col");let n=1/(s*(Math.abs(r)+s)),l=e.mult(n).outer(e),o=this.get_block(t,t);return o=o.sub(l.dot(o)),console.log(l,o),this.set_block(t,t,o),this}householder2(t){let e=this.row(t).slice(t),r=(e.length,e[1]),s=p(e),i=-(r<0?-1:1)*s;e[1]-=i,e=x.from(e,"col");let n=1/(s*(Math.abs(r)+s)),l=e.mult(n).outer(e),o=this.get_block(t,t);return o=o.sub(l.dot(o)),console.log(l,o),this.set_block(t,t,o),this}static bidiagonal(t){t=t.clone();let[e,r]=t.shape;for(let s=0;s<r;++s){let i=t.col(s).slice(s),n=p(i),l=t.col(s).slice(s);l[0]=i[0]+(i[0]<0?-1:1)*n;let o=p(l);l=l.map(t=>t/=o),l=x.from(l,"col");let h=t.get_block(s,s);h=h.sub(l.mult(2).outer(l).dot(h)),t.set_block(s,s,h);for(let r=s+1;r<e;++r)t.set_entry(r,s,0);if(s<=r-2){let e=t.row(s).slice(s+1),i=p(e),n=t.row(s).slice(s+1);n[0]=e[0]+(e[0]<0?-1:1)*i;let l=p(n);n=n.map(t=>t/=l),n=x.from(n,"col");let o=t.get_block(s,s+1);o=o.sub(o.dot(n.mult(2).outer(n))),t.set_block(s,s+1,o);for(let e=s+2;e<r;++e)t.set_entry(s,e,0)}}return t}set_block(t,e,r){let[s,i]=r.shape;for(let n=0;n<s;++n)if(!(n>this._rows))for(let s=0;s<i;++s)s>this._cols||this.set_entry(n+t,s+e,r.entry(n,s));return this}get_block(t,e){let[r,s]=this.shape;return new x(r-t,s-e,(r,s)=>this.entry(r+t,s+e))}_apply(t,e){let r=this._data;if(t instanceof x){let[s,i]=t.shape,[n,l]=this.shape;if(1===s){if(l!==i)return;for(let s=0;s<n;++s)for(let i=0;i<l;++i)r[s*l+i]=e(r[s*l+i],t.entry(0,i))}else if(1===i){if(n!==s)return;for(let s=0;s<n;++s)for(let i=0;i<l;++i)r[s*l+i]=e(r[s*l+i],t.entry(s,0))}else{if(n!=s||l!=i)return;for(let s=0;s<n;++s)for(let i=0;i<l;++i)r[s*l+i]=e(r[s*l+i],t.entry(s,i))}}else if(Array.isArray(t)){let s=this._rows,i=this._cols;if(t.length===s)for(let n=0;n<s;++n)for(let s=0;s<i;++s)r[n*i+s]=e(r[n*i+s],t[n]);else{if(t.length!==i)return;for(let n=0;n<s;++n)for(let s=0;s<i;++s)r[n*i+s]=e(r[n*i+s],t[s])}}else for(let s=0,i=this._rows*this._cols;s<i;++s)r[s]=e(r[s],t);return this}clone(){let t=new x;return t._rows=this._rows,t._cols=this._cols,t._data=this._data.slice(0),t}mult(t){return this.clone()._apply(t,(t,e)=>t*e)}divide(t){return this.clone()._apply(t,(t,e)=>t/e)}add(t){return this.clone()._apply(t,(t,e)=>t+e)}sub(t){return this.clone()._apply(t,(t,e)=>t-e)}get shape(){return[this._rows,this._cols]}set shape([t,e,r=(()=>0)]){this._rows=t,this._cols=e,this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r(s,t);return this}get to2dArray(){const t=this._rows,e=this._cols;let r=new Array(t);for(let s=0;s<t;++s){let t=new Array(e);for(let r=0;r<e;++r)t[r]=this.entry(s,r);r[s]=t}return r}get diag(){const t=this._rows,e=this._cols,r=Math.min(t,e);let s=new Array(r);for(let t=0;t<r;++t)s[t]=this.entry(t,t);return s}get mean(){const t=this._data,e=this._rows*this._cols;let r=0;for(let s=0;s<e;++s)r+=t[s];return r/e}get meanRows(){const t=this._data,e=this._rows,r=this._cols;let s=[];for(let i=0;i<e;++i){s[i]=0;for(let e=0;e<r;++e)s[i]+=t[i*r+e];s[i]/=r}return s}get meanCols(){const t=this._data,e=this._rows,r=this._cols;let s=[];for(let i=0;i<r;++i){s[i]=0;for(let n=0;n<e;++n)s[i]+=t[n*r+i];s[i]/=e}return s}static solve(t,e){let[r,s]=t.shape,{L:i,U:n}=x.LU(t),l=e.clone();for(let t=0;t<r;++t){for(let e=0;e<t-1;++e)l.set_entry(0,t,l.entry(0,t)-i.entry(t,e)*l.entry(1,e));l.set_entry(0,t,l.entry(0,t)/i.entry(t,t))}for(let t=r-1;t>=0;--t){for(let e=r-1;e>t;--e)l.set_entry(0,t,l.entry(0,t)-n.entry(t,e)*l.entry(0,e));l.set_entry(0,t,l.entry(0,t)/n.entry(t,t))}return l}static LU(t){let e,r=t.shape[0],s=new x(r,r,"zeros"),i=new x(r,r,"identity");for(let n=0;n<r;++n){for(let l=n;l<r;++l){e=0;for(let t=0;t<n;++t)e+=s.entry(l,t)*i.entry(t,n);s.set_entry(l,n,t.entry(l,n)-e)}for(let l=n;l<r;++l){if(0===s.entry(n,n))return;e=0;for(let t=0;t<n;++t)e+=s.entry(n,t)*i.entry(t,l);i.set_entry(n,l,(t.entry(n,l)-e)/s.entry(n,n))}}return{L:s,U:i}}static SVD(t,e=2){let r=t.transpose().dot(t),s=t.dot(t.transpose()),{eigenvectors:i,eigenvalues:n}=M(r,e),{eigenvectors:l}=M(s,e);return{U:l,"Σ":n.map(t=>Math.sqrt(t)),V:i}}}class v{constructor(t=null,e=(t=>t),r="min"){if(this.root=null,this.accessor=e,this._comparator="min"==r?(t,e)=>t<=e:"max"==r?(t,e)=>t>=e:r,t&&t.length>0){let e=this;t.forEach(t=>e.push(t))}}push(t){const e=this.accessor(t),r=new N(t,e);if(!this.root||this._comparator(e,this.root.value))r.next=this.root,this.root=r;else{let t=this.root;for(;t.next&&!this._comparator(e,t.next.value);)t=t.next;r.next=t.next,t.next=r}return this}pop(){if(!this.root)return null;const t=this.root;return this.root=this.root.next,t}get first(){return this.root}*iterate(){let t=this.root;for(;t;)yield t.element,t=t.next}toArray(){let t=[],e=this.root;for(;e;)t.push(e.element),e=e.next;return t}get length(){let t=0,e=this.root;for(;e;)t+=1,e=e.next;return t}get empty(){return null===this.root}}class N{constructor(t,e){this.element=t,this.value=e,this.next=null}}t.k_nearest_neighbors=_,t.distance_matrix=h,t.zeros=s,t.linspace=function(t,e,r=null){if(r||(r=Math.max(Math.round(e-t)+1,1)),r<2)return 1===r?[t]:[];let s=new Array(r);for(let i=r-=1;i>=0;--i)s[i]=(i*e+(r-i)*t)/r;return s},t.random_array=f,t.create_array=e,t.identity=function(t){return e(t,t,(t,e)=>t===e?1:0)},t.dot=c,t.mult=y,t.divide=d,t.norm=p,t.transpose=m,t.sub=function(t,e){return w(t,y(e,-1))},t.add=w,t.Matrix=x,t.Vector=class extends Array{constructor(){return super(),this}get norm(){return this}},t.HNSW=class{constructor(t=n,e=!0,r=5,s=200,i=null,l=null){this._metric=t,this._select=e?this._select_heuristic:this._select_simple,this._m=r,this._ef=s,this._m0=i||2*r,this._graph=[],this._ep=null,this._L=null,this._mL=null===l?1/Math.log2(r):l,this.search=this.search}addOne(t){this.add([t])}add(...t){const e=this._m,r=this._ef,s=this._m0,i=this._mL;let n=this._graph;for(const l of t){let t=this._ep?Array.from(this._ep):null,o=[],h=this._L,a=Math.floor(-Math.log(Math.random()*i)),_=Math.min(h,a);if(h){for(let e=n.length-1;e>_;--e)t=this._search_layer(l,t,1,e);for(let i=_;i>=0;--i){let h=n[i];h.points.push(l),o=this._search_layer(l,t,r,i);let a=this._select(l,o,e,i);a.forEach(t=>{t!==l&&(h.edges.push({idx1:t,idx2:l}),h.edges.push({idx1:l,idx2:t}))});let _=0===i?s:e;for(let t of a){let e=h.edges.filter(e=>e.idx1===t).map(t=>t.idx2);if(e.length>_){let r=this._select(t,e,_,i);h.edges=h.edges.filter(e=>e.idx1!==t),r.forEach(e=>{t!==e&&h.edges.push({idx1:t,idx2:e})})}}t=o}}if(n.length<a||a>h){for(let t=a,e=n.length;t>=e;--t){let e={l_c:t,points:[l],edges:new Array};n.push(e),t===a&&(this._ep=[l],this._L=a)}n=n.sort((t,e)=>t.l_c-e.l_c)}}return this}_select_heuristic(t,e,r,s,i=!0,n=!0){if(s>this._graph.length-1)return e;const l=this._metric,o=this._graph[s];let h=[],a=new Set(e);if(i)for(let t of e)for(let{idx2:e}of o.edges.filter(e=>e.idx1===t))a.add(e);let _=new v(Array.from(a),e=>l(e,t),"min"),f=new v(null,e=>l(e,t),"min");for(;_.first&&h.length<r;){let e=_.pop(),r=Math.floor(Math.random()*h.length);0===h.length||e.value<l(h[r],t)?h.push(e.element):f.push(e.element)}if(n)for(;f.first&&h.length<r;)h.push(f.pop().element);return h}_select_simple(t,e,r){const s=this._metric;return e.sort((e,r)=>s(e,t)-s(r,t)).slice(0,r)}_search_layer(t,e,r,s){const i=this._metric,n=this._graph.find(t=>t.l_c===s);let l=new Set(e),o=new v(e,e=>i(e,t),"min"),h=new v(e,e=>i(e,t),"max");for(;o.length>0;){let e=o.pop(),s=h.first;if(e.value>s.value)break;for(let{idx2:a}of n.edges.filter(t=>t.idx1===e.element))l.has(a)||(l.add(a),s=h.first.element,(i(a,t)<i(s,t)||h.length<r)&&(o.push(a),h.push(a),h.length>r&&h.pop()))}return h.toArray().reverse().slice(0,r)}search(t,e,r=null){r=r||1;let s=this._ep;for(let e=this._L;e>0;--e)s=this._search_layer(t,s,r,e);return s=this._search_layer(t,s,e,0)}*search_iter(t,e,r=null){r=r||1;let s=this._ep?Array.from(this._ep):null,i=this._L;yield{l_c:i,ep:[t]};for(let e=i;e>0;--e)yield{l_c:e,ep:s},s=this._search_layer(t,s,r,e),yield{l_c:e,ep:s};yield{l_c:0,ep:s},s=this._search_layer(t,s,e,0),yield{l_c:0,ep:s}}},t.Heap=v,t.euclidean=n,t.cosine=function(t,e){if(t.length!==e.length)return;let r=t.length,s=0,i=0,n=0;for(let l=0;l<r;++l)s+=t[l]*e[l],i+=t[l]*t[l],n+=e[l]*e[l];return s/(Math.sqrt(i)*Math.sqrt(n))},t.manhattan=function(t,e){if(t.length!=e.length)return;let r=t.length,s=0;for(let i=0;i<r;++i)s+=Math.abs(t[i]-e[i]);return s},t.chebyshev=function(t,e){if(t.length!=e.length)return;let r=t.length,s=[];for(let i=0;i<r;++i)s.push(Math.abs(t[i]-e[i]));return Math.max(s)},t.poweriteration=function(t,e=100,r=n){let s=f(t.length,0);for(s=d(s,p(s,r));e--;){let e=c(t,s);s=d(e,p(e,r))}return{eigenvector:s,eigenvalue:c(c(m(t),s),s)/c(s,s)}},t.lanczos=function(t,e=2,s=100,i=n){t instanceof x||(t=x.from(t));let o=t.shape[0],h=new x(o,1,()=>Math.random());h=h.divide(p(h._data,i));let a=t.dot(h),_=a.dot(h),f=a.sub(_.dot(h));for(;s--;)p(f._data,n);return{eigenvector:r,eigenvalue:u/l}},t.sapi=function(t,e=100,r=10,s=.05,i=n){t instanceof x||(t=x.from(t));let l=t.shape[0],o=new x(l,1,()=>Math.random()),h=new x(l,1,0);for(;e--;){let e=t.dot(o),r=h.mult(s),n=e.sub(r),l=p(n._data,i);h=o.divide(l),o=n.divide(l)}let a=o.transpose().dot(t).dot(o),_=o.transpose().dot(o),f=a.divide(_).entry(0,0);return{eigenvector:o.transpose().to2dArray[0],eigenvalue:f}},t.qr=g,t.simultaneous_poweriteration=M,t.lu=function(t){let e,r=t.shape[0],s=new x(r,r,"zeros"),i=new x(r,r,"identity");for(let n=0;n<r;++n){for(let l=n;l<r;++l){e=0;for(let t=0;t<n;++t)e+=s.entry(l,t)*i.entry(t,n);s.set_entry(l,n,t.entry(l,n)-e)}for(let l=n;l<r;++l){if(0===s.entry(n,n))return;e=0;for(let t=0;t<n;++t)e+=s.entry(n,t)*i.entry(t,l);i.set_entry(n,l,(t.entry(n,l)-e)/s.entry(n,n))}}return{L:s,U:i}},t.PCA=class{constructor(t,e=2){this.X=t,this.d=e}transform(){let t=this.X,e=t.shape[1],r=new x(e,e,"center"),s=t.dot(r),i=s.transpose().dot(s),{eigenvectors:n}=M(i,this.d);return console.log(n),n=x.from(n).transpose(),this.Y=t.dot(n),this.Y}get projection(){return this.Y}},t.MDS=class{constructor(t,e=2,r=n){this.X=t,this.d=e,this._metric=r}transform(){let t=this.X,e=t.shape[0],r=[],s=[];for(let t=0;t<e;++t)r.push(0),s.push(0);let i=0,n=new x;n.shape=[e,e,(e,l)=>{let o=0;return e<l?o=this._metric(t.row(e),t.row(l)):e>l&&(o=n.entry(l,e)),r[e]+=o,s[l]+=o,i+=o,o}],r=r.map(t=>t/e),s=s.map(t=>t/e),i/=e**2;let l=new x(e,e,(t,e)=>n.entry(t,e)-r[t]-s[e]+i),{eigenvectors:o}=M(l,this.d);return this.Y=x.from(o).transpose(),this.Y}get projection(){return this.Y}},t.ISOMAP=class{constructor(t,e,r=2,s=n){this.X=t,this.k=e||Math.floor(this.X.shape[0]/10),this.d=r,this._metric=s}transform(){let t=this.X,e=t.shape[0],r=new x;r.shape=[e,e,(e,s)=>e<=s?this._metric(t.row(e),t.row(s)):r.entry(s,e)];let s=[];for(let t=0;t<e;++t){let e=r.row(t).map((t,e)=>({index:e,distance:t})),i=new v(e,t=>t.distance,"min");s.push(i.toArray().slice(1,this.k+1))}let i=new x(e,e,(t,e)=>{let r=s[t].find(t=>t.index===e);return r?r.distance:1/0});for(let t=0;t<e;++t)for(let r=0;r<e;++r)for(let s=0;s<e;++s)i.set_entry(t,r,Math.min(i.entry(t,r),i.entry(t,s)+i.entry(s,r)));let n=[],l=[];for(let t=0;t<e;++t)n.push(0),l.push(0);let o=0,h=new x(e,e,(t,e)=>{let r=i.entry(t,e);return r=r===1/0?0:r,n[t]+=r,l[e]+=r,o+=r,r});n=n.map(t=>t/e),l=l.map(t=>t/e),o/=e**2;let a=new x(e,e,(t,e)=>h.entry(t,e)-n[t]-l[e]+o),{eigenvectors:_}=M(a,this.d);return this.Y=x.from(_).transpose(),this.Y}get projection(){return this.Y}},t.FASTMAP=class{constructor(t,e=2,r=n){this.X=t,this.d=e,this._metric=r,this._col=-1,this.randomizer=new A(1212)}_choose_distant_objects(t){let e=this.X.shape[0],r=this.randomizer.random_int%e-1,s=null,i=-1/0;for(let n=0;n<e;++n){let e=t(r,n);e>i&&(i=e,s=n)}i=-1/0;for(let n=0;n<e;++n){let e=t(s,n);e>i&&(i=e,r=n)}return[r,s,i]}transform(){let t=this.X,[e,r]=t.shape,s=new x(e,this.d),i=(e,r)=>this._metric(t.row(e),t.row(r)),n=i;for(;this._col<this.d-1;){this._col+=1;let t=this._col,[r,l,o]=this._choose_distant_objects(i);if(0===o)for(let r=0;r<e;++r)s.set_entry(r,t,0);else{for(let n=0;n<e;++n){let e=(i(r,n)**2+o**2-i(l,n)**2)/(2*o);s.set_entry(n,t,e)}i=((e,r)=>Math.sqrt(n(e,r)**2-(s.entry(e,t)-s.entry(r,t))**2))}}return this.Y=s,this.Y}get projection(){return this.Y}},t.LDA=class{constructor(t,e,r=2,s=n){this.X=t,this._labels=e,this.d=r,this._metric=s}transform(){let t=this.X,[e,r]=t.shape,s=this._labels,i={},n=0;s.forEach((e,r)=>{e in i?(i[e].count++,i[e].rows.push(t.row(r))):i[e]={id:n++,count:1,rows:[t.row(r)]}});let l=t.mean,o=new x(n,r);for(let t in i){let e=x.from(i[t].rows).meanCols;for(let s=0;s<r;++s)o.set_entry(i[t].id,s,e[s])}let h=new x(r,r);for(let t in i){let e=o.row(i[t].id),s=new x(r,1,t=>e[t]-l),n=i[t].count;h=h.add(s.dot(s.transpose()).mult(n))}let a=new x(r,r);for(let t in i){let e=o.row(i[t].id),s=new x(r,1,t=>e[t]),n=i[t].rows;for(let e=0,l=i[t].count;e<l;++e){let t=new x(r,1,(t,r)=>n[e][t]-s.entry(t,0));a=a.add(t.dot(t.transpose()))}}let{eigenvectors:_}=M(a.inverse().dot(h),this.d);return _=x.from(_).transpose(),this.Y=t.dot(_),this.Y}get projection(){return this.Y}},t.LLE=class{constructor(t,e,r=2,s=n){this.X=t,this._k=e,this.d=r,this._metric=s}transform(){let t=this.X,e=this.d,[r,s]=t.shape,n=this._k,l=_(t.to2dArray,n,null,this._metric),o=new x(n,1,1),h=new x(r,r);for(let e=0;e<r;++e){let r=new x(n,s,(r,s)=>t.entry(l[e][r].j,s)-t.entry(e,s)),a=r.dot(r.transpose());if(n>s){let t=i(a.diag)/1e3;for(let e=0;e<n;++e)a.set_entry(e,e,a.entry(e,e)+t)}let _=x.solve(a,o),f=i(_.col(0));_=_.divide(f);for(let t=0;t<n;++t)h.set_entry(e,l[e][t].j,_.entry(t,0))}let a=new x(r,r,"identity").sub(h),f=a.transpose().dot(a),{eigenvectors:u}=M(f.transpose().inverse(),e+1);return this.Y=x.from(u.slice(1,1+e)).transpose(),this.Y}get projection(){return this.Y}},t.MLLE=class{constructor(t,e,r=2,s=n){this.X=t,this._k=e,this.d=r,this._metric=s}transform(){let t=this.X,e=this.d,[r,s]=t.shape,n=this._k,l=_(t.to2dArray,n,null,this._metric),o=new x(n,1,1),h=new x(r,n),a=new x(r,r),f=new Array(r),u=new Array(r),c=new Array(r);for(let s=0;s<r;++s){let r=l[s].map(t=>t.j),a=x.from(t.row(s),"row"),_=x.from(r.map(e=>t.row(e))),y=(_=_.sub(a)).dot(_.transpose()),d=i(y.diag)/1e3;for(let t=0;t<n;++t)y.set_entry(t,t,y.entry(t,t)+d);let{eigenvalues:p,eigenvectors:m}=M(y,n);f[s]=m,u[s]=p,c.push(i(p.slice(e+1))/i(p.slice(0,e)));let w=x.solve(y,o),g=i(w.col(0));w=w.divide(g);for(let t=0;t<n;++t)h.set_entry(s,t,w.entry(t,0))}let y=c.sort((t,e)=>t-e)[Math.ceil(r/2)];for(let t=0;t<r;++t){let r=l[t].map(t=>t.j),s=u[t],o=s.map((t,e)=>({l:e,ratio:i(s.slice(n-e+1))/i(s.slice(0,n-e)),"λ":t}));o=o.filter(t=>t.ratio<y&&t.l<=n-e).map(t=>t.l).pop()||e;let _=f[t];_=_.slice(n-o);let c=1/Math.sqrt(o)*p(_[0].map((t,e)=>i(_.map(t=>t[e]))));_=x.from(_);let d=new x(o,1,c),m=new x(n,1,1),w=p((d=d.sub(_.dot(m))).col(0));d=w<1e-12?d.mult(0):d.divide(w),_=_.T,m=new x(o,1,1);let g=x.from(h.row(t),"col"),A=_.sub(_.dot(d).dot(d.T).mult(2)).add(g.mult(1-c).dot(m.T));A=A.dot(A.T);for(let t=0;t<n+1;++t)for(let e=0;e<o;++e)a.set_entry(r[t],r[e],a.entry(r[t],r[e])-(t===e?1:0)+A.entry(t,e))}let{eigenvectors:d}=M(a,e+1);return this.Y=x.from(d.slice(1)).transpose(),this.Y}get projection(){return this.Y}},t.LTSA=class{constructor(t,e,r=2,s=n){this.X=t,this._k=e,this.d=r,this._metric=s}transform(){let t=this.X,e=this.d,[r,s]=t.shape,i=this._k,n=_(t.to2dArray,i,null,this._metric),l=new x(s,s,"center"),o=new x(r,r,0);for(let s=0;s<r;++s){let r=[s,...n[s].map(t=>t.j)],h=x.from(r.map(e=>t.row(e))),a=(h=h.dot(l)).dot(h.transpose()),{eigenvectors:_}=M(a,e),f=x.from(_),u=f.transpose().dot(f).add(1/Math.sqrt(i+1));for(let t=0;t<i+1;++t)for(let e=0;e<i+1;++e)o.set_entry(r[t],r[e],o.entry(r[t],r[e])-(t===e?1:0)+u.entry(t,e))}let{eigenvectors:h}=M(o,e+1);return this.Y=x.from(h.slice(1)).transpose(),this.Y}get projection(){return this.Y}},t.TSNE=class{constructor(t,e,r,s=2,i=n,l=1212){this._X=t,this._d=s,[this._N,this._D]=t.shape,this._perplexity=e,this._epsilon=r,this._metric=i,this._iter=0,this.randomizer=new A(l),this._Y=new x(this._N,this._N,()=>this.randomizer.random)}init(t=null){let e=Math.log(this._perplexity),r=t||new x(this._N,this._N,(t,e)=>this._metric(this._X.row(t),this._X.row(e))),s=new x(this._N,this._N,"zeros");this._ystep=new x(this._N,this._D,"zeros").to2dArray,this._gains=new x(this._N,this._D,1).to2dArray;let i=new Array(this._N).fill(0);for(let t=0,n=this._N;t<n;++t){let l=-1/0,o=1/0,h=1,a=!1,_=50,f=1e-4,u=0;for(;!a;){let s=0;for(let e=0;e<n;++e){let n=Math.exp(-r.entry(t,e)*h);t===e&&(n=0),i[e]=n,s+=n}let c=0;for(let t=0;t<n;++t){let e=0===s?0:i[t]/s;i[t]=e,e>1e-7&&(c-=e*Math.log(e))}c>e?(l=h,h=o===1/0?2*h:(h+o)/2):(o=h,h=l===-1/0?h/2:(h+l)/2),++u,Math.abs(c-e)<f&&(a=!0),u>=_&&(a=!0)}for(let e=0;e<n;++e)s.set_entry(t,e,i[e])}let n=new x(this._N,this._N,"zeros"),l=2*this._N;for(let t=0,e=this._N;t<e;++t)for(let r=0;r<e;++r)n.set_entry(t,r,Math.max((s.entry(t,r)+s.entry(r,t))/l,1e-100));return this._P=n,this}set perplexity(t){this._perplexity=t}get perplexity(){return this._perplexity}set epsilon(t){this._epsilon=t}get epsilon(){return this._epsilon}transform(t=1e3){for(let e=0;e<t;++e)this.next();return this._Y}*transform_iter(){for(;;)this.next(),yield this._Y}next(){let t=++this._iter,e=this._P,r=this._ystep,s=this._gains,i=this._Y,n=this._N,l=this._epsilon,o=this._d,h=t<100?4:1,a=new x(n,n,"zeros"),_=0;for(let t=0;t<n;++t)for(let e=t+1;e<n;++e){let r=0;for(let s=0;s<o;++s){let n=i.entry(t,s)-i.entry(e,s);r+=n*n}let s=1/(1+r);a.set_entry(t,e,s),a.set_entry(e,t,s),_+=2*s}let f=new x(n,n,(t,e)=>Math.max(a.entry(t,e)/_,1e-100)),u=0,c=[];for(let t=0;t<n;++t){let r=new Array(o).fill(0);for(let s=0;s<n;++s){u+=-e.entry(t,s)*Math.log(f.entry(t,s));let n=4*(h*e.entry(t,s)-f.entry(t,s))*a.entry(t,s);for(let e=0;e<o;++e)r[e]+=n*(i.entry(t,e)-i.entry(s,e))}c.push(r)}let y=new Array(o).fill(0);for(let e=0;e<n;++e)for(let n=0;n<o;++n){let o=c[e][n],h=r[e][n],a=s[e][n],_=Math.sign(o)===Math.sign(h)?.8*a:a+.2;_<.01&&(_=.01),s[e][n]=_;let f=(t<250?.5:.8)*h-l*_*c[e][n];r[e][n]=f,i.set_entry(e,n,i.entry(e,n)+f),y[n]+=i.entry(e,n)}for(let t=0;t<n;++t)for(let e=0;e<2;++e)i.set_entry(t,e,i.entry(t,e)-y[e]/n);return this._Y}get projection(){return this._Y}},t.UMAP=class{constructor(t,e,r,s=2,i=n){this._X=t,this._d=s,[this._N,this._D]=t.shape,this._local_connectivity=e,this._min_dist=r,this._metric=i,this._iter=0}init(t=null,e=1212){this.randomizer=new A(e),this._Y=new x(this._N,this._N,()=>this.randomizer.random);let r=Math.log(this._perplexity),s=t||new x(this._N,this._N,(t,e)=>this._metric(this._X.row(t),this._X.row(e))),i=new x(this._N,this._N,"zeros");this._ystep=new x(this._N,this._D,"zeros").to2dArray,this._gains=new x(this._N,this._D,1).to2dArray;let n=new Array(this._N).fill(0);for(let t=0,e=this._N;t<e;++t){let l=-1/0,o=1/0,h=1,a=!1,_=50,f=1e-4,u=0;for(;!a;){let i=0;for(let r=0;r<e;++r){let e=Math.exp(-s.entry(t,r)*h);t===r&&(e=0),n[r]=e,i+=e}let c=0;for(let t=0;t<e;++t){let e=0===i?0:n[t]/i;n[t]=e,e>1e-7&&(c-=e*Math.log(e))}c>r?(l=h,h=o===1/0?2*h:(h+o)/2):(o=h,h=l===-1/0?h/2:(h+l)/2),++u,Math.abs(c-r)<f&&(a=!0),u>=_&&(a=!0)}for(let r=0;r<e;++r)i.set_entry(t,r,n[r])}let l=new x(this._N,this._N,"zeros"),o=2*this._N;for(let t=0,e=this._N;t<e;++t)for(let r=0;r<e;++r)l.set_entry(t,r,Math.max((i.entry(t,r)+i.entry(r,t))/o,1e-100));return this._P=l,this}set perplexity(t){this._perplexity=t}get perplexity(){return this._perplexity}set epsilon(t){this._epsilon=t}get epsilon(){return this._epsilon}transform(t=1e3){for(let e=0;e<t;++e)this.next();return this._Y}*transform_iter(){for(;;)this.next(),yield this._Y}next(){let t=++this._iter,e=this._P,r=this._ystep,s=this._gains,i=this._Y,n=this._N,l=this._epsilon,o=this._d,h=t<100?4:1,a=new x(n,n,"zeros"),_=0;for(let t=0;t<n;++t)for(let e=t+1;e<n;++e){let r=0;for(let s=0;s<o;++s){let n=i.entry(t,s)-i.entry(e,s);r+=n*n}let s=1/(1+r);a.set_entry(t,e,s),a.set_entry(e,t,s),_+=2*s}let f=new x(n,n,(t,e)=>Math.max(a.entry(t,e)/_,1e-100)),u=0,c=[];for(let t=0;t<n;++t){let r=new Array(o).fill(0);for(let s=0;s<n;++s){u+=-e.entry(t,s)*Math.log(f.entry(t,s));let n=4*(h*e.entry(t,s)-f.entry(t,s))*a.entry(t,s);for(let e=0;e<o;++e)r[e]+=n*(i.entry(t,e)-i.entry(s,e))}c.push(r)}let y=new Array(o).fill(0);for(let e=0;e<n;++e)for(let n=0;n<o;++n){let o=c[e][n],h=r[e][n],a=s[e][n],_=Math.sign(o)===Math.sign(h)?.8*a:a+.2;_<.01&&(_=.01),s[e][n]=_;let f=(t<250?.5:.8)*h-l*_*c[e][n];r[e][n]=f,i.set_entry(e,n,i.entry(e,n)+f),y[n]+=i.entry(e,n)}for(let t=0;t<n;++t)for(let e=0;e<2;++e)i.set_entry(t,e,i.entry(t,e)-y[e]/n);return this._Y}get projection(){return this._Y}},t.Randomizer=A,t.kahan_sum=function(t){let e,r,s=t.length,i=0,n=0;for(let l=0;l<s;++l)n=(r=i+(e=t[l]-n))-i-e,i=r;return i},t.neumair_sum=i,Object.defineProperty(t,"__esModule",{value:!0})});
